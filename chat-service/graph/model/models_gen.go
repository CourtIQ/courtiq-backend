// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Chat interface {
	IsEntity()
	IsChat()
	GetID() primitive.ObjectID
	GetParticipantIds() []primitive.ObjectID
	GetType() ChatType
	GetCreatedAt() time.Time
	GetUpdatedAt() time.Time
}

type Message interface {
	IsEntity()
	IsMessage()
	GetID() primitive.ObjectID
	GetChatID() primitive.ObjectID
	GetSenderID() primitive.ObjectID
	GetCreatedAt() time.Time
	GetUpdatedAt() time.Time
	GetType() MessageType
}

type GroupChat struct {
	ID             primitive.ObjectID   `json:"id" bson:"_id"`
	ParticipantIds []primitive.ObjectID `json:"participantIds" bson:"participantIds"`
	Type           ChatType             `json:"type" bson:"type"`
	CreatedAt      time.Time            `json:"createdAt" bson:"createdAt"`
	UpdatedAt      time.Time            `json:"updatedAt" bson:"updatedAt"`
	Name           string               `json:"name" bson:"name"`
	ImageURL       *string              `json:"imageUrl,omitempty" bson:"imageUrl,omitempty"`
	OwnerID        primitive.ObjectID   `json:"ownerId" bson:"ownerId"`
}

func (GroupChat) IsChat()                        {}
func (this GroupChat) GetID() primitive.ObjectID { return this.ID }
func (this GroupChat) GetParticipantIds() []primitive.ObjectID {
	if this.ParticipantIds == nil {
		return nil
	}
	interfaceSlice := make([]primitive.ObjectID, 0, len(this.ParticipantIds))
	for _, concrete := range this.ParticipantIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this GroupChat) GetType() ChatType       { return this.Type }
func (this GroupChat) GetCreatedAt() time.Time { return this.CreatedAt }
func (this GroupChat) GetUpdatedAt() time.Time { return this.UpdatedAt }

func (GroupChat) IsEntity() {}

type ImageMessage struct {
	ID        primitive.ObjectID `json:"id" bson:"_id"`
	ChatID    primitive.ObjectID `json:"chatId" bson:"chatId"`
	SenderID  primitive.ObjectID `json:"senderId" bson:"senderId"`
	CreatedAt time.Time          `json:"createdAt" bson:"createdAt"`
	UpdatedAt time.Time          `json:"updatedAt" bson:"updatedAt"`
	Type      MessageType        `json:"type" bson:"type"`
	URL       string             `json:"url" bson:"url"`
}

func (ImageMessage) IsMessage()                           {}
func (this ImageMessage) GetID() primitive.ObjectID       { return this.ID }
func (this ImageMessage) GetChatID() primitive.ObjectID   { return this.ChatID }
func (this ImageMessage) GetSenderID() primitive.ObjectID { return this.SenderID }
func (this ImageMessage) GetCreatedAt() time.Time         { return this.CreatedAt }
func (this ImageMessage) GetUpdatedAt() time.Time         { return this.UpdatedAt }
func (this ImageMessage) GetType() MessageType            { return this.Type }

func (ImageMessage) IsEntity() {}

// Provides structured geographical details about a user's location.
// All fields are optional and can be omitted if unknown.
type Location struct {
	City      *string  `json:"city,omitempty" bson:"city,omitempty"`
	State     *string  `json:"state,omitempty" bson:"state,omitempty"`
	Country   *string  `json:"country,omitempty" bson:"country,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" bson:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" bson:"longitude,omitempty"`
}

type Mutation struct {
}

type PrivateChat struct {
	ID             primitive.ObjectID   `json:"id" bson:"_id"`
	ParticipantIds []primitive.ObjectID `json:"participantIds" bson:"participantIds"`
	Type           ChatType             `json:"type" bson:"type"`
	CreatedAt      time.Time            `json:"createdAt" bson:"createdAt"`
	UpdatedAt      time.Time            `json:"updatedAt" bson:"updatedAt"`
}

func (PrivateChat) IsChat()                        {}
func (this PrivateChat) GetID() primitive.ObjectID { return this.ID }
func (this PrivateChat) GetParticipantIds() []primitive.ObjectID {
	if this.ParticipantIds == nil {
		return nil
	}
	interfaceSlice := make([]primitive.ObjectID, 0, len(this.ParticipantIds))
	for _, concrete := range this.ParticipantIds {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this PrivateChat) GetType() ChatType       { return this.Type }
func (this PrivateChat) GetCreatedAt() time.Time { return this.CreatedAt }
func (this PrivateChat) GetUpdatedAt() time.Time { return this.UpdatedAt }

func (PrivateChat) IsEntity() {}

type Query struct {
}

type TextMessage struct {
	ID        primitive.ObjectID `json:"id" bson:"_id"`
	ChatID    primitive.ObjectID `json:"chatId" bson:"chatId"`
	SenderID  primitive.ObjectID `json:"senderId" bson:"senderId"`
	CreatedAt time.Time          `json:"createdAt" bson:"createdAt"`
	UpdatedAt time.Time          `json:"updatedAt" bson:"updatedAt"`
	Type      MessageType        `json:"type" bson:"type"`
	Text      string             `json:"text" bson:"text"`
}

func (TextMessage) IsMessage()                           {}
func (this TextMessage) GetID() primitive.ObjectID       { return this.ID }
func (this TextMessage) GetChatID() primitive.ObjectID   { return this.ChatID }
func (this TextMessage) GetSenderID() primitive.ObjectID { return this.SenderID }
func (this TextMessage) GetCreatedAt() time.Time         { return this.CreatedAt }
func (this TextMessage) GetUpdatedAt() time.Time         { return this.UpdatedAt }
func (this TextMessage) GetType() MessageType            { return this.Type }

func (TextMessage) IsEntity() {}

type ChatType string

const (
	ChatTypePrivate ChatType = "PRIVATE"
	ChatTypeGroup   ChatType = "GROUP"
)

var AllChatType = []ChatType{
	ChatTypePrivate,
	ChatTypeGroup,
}

func (e ChatType) IsValid() bool {
	switch e {
	case ChatTypePrivate, ChatTypeGroup:
		return true
	}
	return false
}

func (e ChatType) String() string {
	return string(e)
}

func (e *ChatType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ChatType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ChatType", str)
	}
	return nil
}

func (e ChatType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MessageType string

const (
	MessageTypeText           MessageType = "TEXT"
	MessageTypeMatchupRequest MessageType = "MATCHUP_REQUEST"
)

var AllMessageType = []MessageType{
	MessageTypeText,
	MessageTypeMatchupRequest,
}

func (e MessageType) IsValid() bool {
	switch e {
	case MessageTypeText, MessageTypeMatchupRequest:
		return true
	}
	return false
}

func (e MessageType) String() string {
	return string(e)
}

func (e *MessageType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MessageType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MessageType", str)
	}
	return nil
}

func (e MessageType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
