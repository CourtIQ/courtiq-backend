// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/CourtIQ/courtiq-backend/matchup-service/graph/schema/scalars"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Used to create a new tennis match with the specified type, format, and participants.
// If 'visibility' is not provided, it defaults to 'PRIVATE'.
type InitiateMatchUpInput struct {
	// The type of match, e.g., SINGLES or DOUBLES.
	MatchUpType MatchUpType `json:"matchUpType" bson:"matchUpType"`
	// The format and rules for this match (sets, tiebreak details, etc.).
	MatchUpFormat *MatchUpFormatInput `json:"matchUpFormat" bson:"matchUpFormat"`
	// The players or teams participating in the match.
	Participants []*ParticipantInput `json:"participants" bson:"participants"`
	// A reference or ID used to track/log this match (e.g., analytics or
	// a parent entity).
	MatchUpTracker primitive.ObjectID `json:"matchUpTracker" bson:"matchUpTracker"`
	// The participant (by ObjectID) who will serve first.
	InitialServer primitive.ObjectID `json:"initialServer" bson:"initialServer"`
	// Determines who can view or access details of the match; defaults to PRIVATE.
	Visibility *Visibility `json:"visibility,omitempty" bson:"visibility,omitempty"`
}

// Provides structured geographical details about a user's location.
// All fields are optional and can be omitted if unknown.
type Location struct {
	City      *string  `json:"city,omitempty" bson:"city,omitempty"`
	State     *string  `json:"state,omitempty" bson:"state,omitempty"`
	Country   *string  `json:"country,omitempty" bson:"country,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" bson:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" bson:"longitude,omitempty"`
}

type MatchUp struct {
	ID                 primitive.ObjectID `json:"id" bson:"_id"`
	Owner              primitive.ObjectID `json:"owner" bson:"owner"`
	MatchUpFormat      *MatchUpFormat     `json:"matchUpFormat" bson:"matchUpFormat"`
	MatchUpTracker     primitive.ObjectID `json:"matchUpTracker" bson:"matchUpTracker"`
	MatchUpType        MatchUpType        `json:"matchUpType" bson:"matchUpType"`
	MatchUpStatus      MatchUpStatus      `json:"matchUpStatus" bson:"matchUpStatus"`
	Participants       []*Participant     `json:"participants" bson:"participants"`
	InitialServer      primitive.ObjectID `json:"initialServer" bson:"initialServer"`
	ScheduledStartTime *time.Time         `json:"scheduledStartTime,omitempty" bson:"scheduledStartTime,omitempty"`
	StartTime          *time.Time         `json:"startTime,omitempty" bson:"startTime,omitempty"`
	EndTime            *time.Time         `json:"endTime,omitempty" bson:"endTime,omitempty"`
	CreatedAt          time.Time          `json:"createdAt" bson:"createdAt"`
	LastUpdated        time.Time          `json:"lastUpdated" bson:"lastUpdated"`
	Visibility         Visibility         `json:"visibility" bson:"visibility"`
}

// Overall "ruleset" of a tennis match:
// - Total sets (NumberOfSets)
// - Format details for each set
// - Optional alternate final set format
type MatchUpFormat struct {
	// How many sets will be played, restricted by the NumberOfSets scalar.
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// Default set format (e.g., games needed, deuce rules, etc.).
	SetFormat *SetFormat `json:"setFormat" bson:"setFormat"`
	// Alternate rules for the final set (e.g., 10-point tiebreak).
	// May be null if not used.
	FinalSetFormat *SetFormat `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

// Input representation of MatchUpFormat,
// mirroring the MatchUpFormat type.
type MatchUpFormatInput struct {
	// How many total sets are played, restricted by NumberOfSets (1, 3, 5).
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// The default format for all sets except possibly the final one.
	SetFormat *SetFormatInput `json:"setFormat" bson:"setFormat"`
	// Alternate final set format, e.g., to allow a 10-point tiebreak.
	// Optional (null) if not used.
	FinalSetFormat *SetFormatInput `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

type MatchUpPoint struct {
	ID        primitive.ObjectID `json:"id" bson:"_id"`
	MatchUpID primitive.ObjectID `json:"matchUpId" bson:"matchUpId"`
	Winner    TeamSide           `json:"winner" bson:"winner"`
	Loser     TeamSide           `json:"loser" bson:"loser"`
	Server    *Participant       `json:"server" bson:"server"`
	Timestamp *time.Time         `json:"timestamp,omitempty" bson:"timestamp,omitempty"`
}

// The main container for all real-time or final scoring data.
// - An array of completed/in-progress sets
// - The current in-game point score (if not in tiebreak)
// - A flag for whether the match is finished
type MatchUpScore struct {
	// A list of set-by-set scoring details.
	// Each SetScore holds how many games each side has,
	// and whether a tiebreak is in progress.
	Sets []*SetScore `json:"sets" bson:"sets"`
	// The partial "point level" for the current (not-yet-finished) game,
	// if the match is not in a tiebreak. Each entry references a side
	// (TEAM_A or TEAM_B) and an InGamePoint.
	CurrentGame []*SideGameScore `json:"currentGame" bson:"currentGame"`
	// Indicates if the match is fully decided (someone reached
	// the required sets).
	IsMatchComplete bool `json:"isMatchComplete" bson:"isMatchComplete"`
}

type MatchUpShot struct {
	ShotType ShotType `json:"shotType" bson:"shotType"`
}

type Mutation struct {
}

// Represents an individual participant in a tennis match (could be a singles player
// or one of the doubles players). Each participant is associated with one 'team side'
// (e.g., Team A or Team B).
type Participant struct {
	// A unique identifier for the participant.
	ID string `json:"id" bson:"_id"`
	// The name to be displayed (e.g., on scoreboards or UIs).
	DisplayName string `json:"displayName" bson:"displayName"`
	// The side (A or B) that this participant is associated with.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
}

// Represents the information needed to create or link a participant
// (e.g., a player) in a tennis match. If the participant already exists
// in the database (i.e., a registered user), 'id' should be provided.
// If 'id' is omitted or null, the participant will be treated as a 'guest'
// and stored in a separate guests collection.
type ParticipantInput struct {
	// If provided, this corresponds to an existing user in the database.
	// If omitted or null, the participant is treated as a guest and stored separately.
	ID primitive.ObjectID `json:"id" bson:"_id"`
	// The participant's display name.
	DisplayedName string `json:"displayedName" bson:"displayedName"`
	// The side (TEAM_A or TEAM_B) that this participant will play on.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
}

type Query struct {
}

// Describes a single set's structure:
// - Number of games (NumberOfGames)
// - Deuce rules
// - Tiebreak rules
type SetFormat struct {
	// Number of games to win a set, enforced by the NumberOfGames scalar.
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (Advantage, No-Ad, etc.).
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// If true, a player must lead by two games when at deuce.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// How the tiebreak is handled, if triggered.
	TiebreakFormat *TiebreakFormat `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
	// The game score at which a tiebreak starts (commonly 6).
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Input representation of SetFormat,
// mirroring the SetFormat type.
type SetFormatInput struct {
	// Number of games required to win a set (allowed values: 1, 3, 4, 5, 6, 10).
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (e.g., ADV or NO_AD).
	// This remains required because you must specify some deuce rule.
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// Whether a two-game lead is required to close the set.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// Optional tiebreak specification.
	// If omitted, it implies that no tiebreak is used.
	TiebreakFormat *TiebreakFormatInput `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
	// Optional "trigger" at which a tiebreak starts (commonly 6).
	// If omitted or null, no tiebreak is triggered at any game score.
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Each set in a tennis match. If 'isCompleted' is true,
// one side has won this set (e.g., 6-4), possibly via tiebreak.
type SetScore struct {
	// Which set number (e.g., 0-based or 1-based).
	SetIndex int `json:"setIndex" bson:"setIndex"`
	// Scores for the two sides: how many games they've won,
	// and any tiebreak points if relevant.
	Sides []*SideSetScore `json:"sides" bson:"sides"`
	// True if this set has been fully won by one side.
	IsCompleted bool `json:"isCompleted" bson:"isCompleted"`
	// True if a tiebreak is currently active (i.e., partial tiebreak),
	// or false if no tiebreak is in progress or it already finished.
	IsTiebreakActive bool `json:"isTiebreakActive" bson:"isTiebreakActive"`
}

// Represents the in-progress point score for an ongoing game.
// If the match is in a tiebreak (isTiebreakActive=true),
// you might ignore 'currentGame' and track 'tiebreakPoints' instead.
type SideGameScore struct {
	Side        TeamSide    `json:"side" bson:"side"`
	InGamePoint InGameScore `json:"inGamePoint" bson:"inGamePoint"`
}

// Holds the game-level data for each side of a set:
// - gamesWon
// - tiebreakPoints (if a tiebreak is ongoing or completed)
type SideSetScore struct {
	Side           TeamSide `json:"side" bson:"side"`
	GamesWon       int      `json:"gamesWon" bson:"gamesWon"`
	TiebreakPoints *int     `json:"tiebreakPoints,omitempty" bson:"tiebreakPoints,omitempty"`
}

// Defines how a tiebreak is played:
// - Points needed (TiebreakPoints)
// - Whether a two-point lead is required
type TiebreakFormat struct {
	// How many points are needed to win the tiebreak
	// (allowed values: 5, 6, 7, 8, 9, 10).
	Points string `json:"points" bson:"points"`
	// If true, a two-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
}

// Input representation of TiebreakFormat,
// mirroring the TiebreakFormat type.
type TiebreakFormatInput struct {
	// Points needed to win the tiebreak (5, 6, 7, 8, 9, or 10).
	Points string `json:"points" bson:"points"`
	// If true, a 2-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
}

// Specifies the deuce rule, i.e., how a game proceeds once it reaches a 40-40 score.
type DeuceType string

const (
	// Sudden-death format: once the score reaches deuce (40-40),
	// the very next point decides the game — no requirement to win by two points.
	DeuceTypeSuddenDeath DeuceType = "SUDDEN_DEATH"
	// Traditional deuce format: a player must secure a two-point lead to win
	// (i.e., 'advantage' followed by another point).
	DeuceTypeNormalDeuce DeuceType = "NORMAL_DEUCE"
	// One-deuce format: once the score reaches deuce, only one deuce is allowed.
	// After that, the next point wins the game, regardless of any lead requirement.
	DeuceTypeOneDeuce DeuceType = "ONE_DEUCE"
)

var AllDeuceType = []DeuceType{
	DeuceTypeSuddenDeath,
	DeuceTypeNormalDeuce,
	DeuceTypeOneDeuce,
}

func (e DeuceType) IsValid() bool {
	switch e {
	case DeuceTypeSuddenDeath, DeuceTypeNormalDeuce, DeuceTypeOneDeuce:
		return true
	}
	return false
}

func (e DeuceType) String() string {
	return string(e)
}

func (e *DeuceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeuceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeuceType", str)
	}
	return nil
}

func (e DeuceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroundStrokeStyle string

const (
	GroundStrokeStyleSlice       GroundStrokeStyle = "SLICE"
	GroundStrokeStyleTopspin     GroundStrokeStyle = "TOPSPIN"
	GroundStrokeStyleFlat        GroundStrokeStyle = "FLAT"
	GroundStrokeStyleLob         GroundStrokeStyle = "LOB"
	GroundStrokeStyleDropShot    GroundStrokeStyle = "DROP_SHOT"
	GroundStrokeStyleCrosscourt  GroundStrokeStyle = "CROSSCOURT"
	GroundStrokeStyleDownTheLine GroundStrokeStyle = "DOWN_THE_LINE"
	GroundStrokeStyleSmash       GroundStrokeStyle = "SMASH"
)

var AllGroundStrokeStyle = []GroundStrokeStyle{
	GroundStrokeStyleSlice,
	GroundStrokeStyleTopspin,
	GroundStrokeStyleFlat,
	GroundStrokeStyleLob,
	GroundStrokeStyleDropShot,
	GroundStrokeStyleCrosscourt,
	GroundStrokeStyleDownTheLine,
	GroundStrokeStyleSmash,
}

func (e GroundStrokeStyle) IsValid() bool {
	switch e {
	case GroundStrokeStyleSlice, GroundStrokeStyleTopspin, GroundStrokeStyleFlat, GroundStrokeStyleLob, GroundStrokeStyleDropShot, GroundStrokeStyleCrosscourt, GroundStrokeStyleDownTheLine, GroundStrokeStyleSmash:
		return true
	}
	return false
}

func (e GroundStrokeStyle) String() string {
	return string(e)
}

func (e *GroundStrokeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeStyle", str)
	}
	return nil
}

func (e GroundStrokeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroundStrokeType string

const (
	GroundStrokeTypeForehand GroundStrokeType = "FOREHAND"
	GroundStrokeTypeBackhand GroundStrokeType = "BACKHAND"
)

var AllGroundStrokeType = []GroundStrokeType{
	GroundStrokeTypeForehand,
	GroundStrokeTypeBackhand,
}

func (e GroundStrokeType) IsValid() bool {
	switch e {
	case GroundStrokeTypeForehand, GroundStrokeTypeBackhand:
		return true
	}
	return false
}

func (e GroundStrokeType) String() string {
	return string(e)
}

func (e *GroundStrokeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeType", str)
	}
	return nil
}

func (e GroundStrokeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents a single side's in-game scoring state in traditional tennis.
type InGameScore string

const (
	// 0 points in the current game.
	InGameScoreZero InGameScore = "ZERO"
	// 15 points in the current game.
	InGameScoreFifteen InGameScore = "FIFTEEN"
	// 30 points in the current game.
	InGameScoreThirty InGameScore = "THIRTY"
	// 40 points in the current game.
	InGameScoreForty InGameScore = "FORTY"
	// Advantage. Occurs when both players reach 40.
	InGameScoreAdv InGameScore = "ADV"
)

var AllInGameScore = []InGameScore{
	InGameScoreZero,
	InGameScoreFifteen,
	InGameScoreThirty,
	InGameScoreForty,
	InGameScoreAdv,
}

func (e InGameScore) IsValid() bool {
	switch e {
	case InGameScoreZero, InGameScoreFifteen, InGameScoreThirty, InGameScoreForty, InGameScoreAdv:
		return true
	}
	return false
}

func (e InGameScore) String() string {
	return string(e)
}

func (e *InGameScore) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InGameScore(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InGameScore", str)
	}
	return nil
}

func (e InGameScore) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the different stages or outcomes a tennis match can go through.
type MatchUpStatus string

const (
	// The match is scheduled in advance but has not yet started.
	MatchUpStatusScheduled MatchUpStatus = "SCHEDULED"
	// The match is currently in progress.
	MatchUpStatusInProgress MatchUpStatus = "IN_PROGRESS"
	// The match has ended with a clear result (winner determined).
	MatchUpStatusCompleted MatchUpStatus = "COMPLETED"
	// The match has been paused (e.g., due to weather or other external conditions)
	// and is expected to resume later.
	MatchUpStatusSuspended MatchUpStatus = "SUSPENDED"
	// The match has been canceled and will not be played or resumed.
	MatchUpStatusCancelled MatchUpStatus = "CANCELLED"
	// The match was started but ultimately abandoned partway and will not be completed.
	MatchUpStatusAbandoned MatchUpStatus = "ABANDONED"
	// One player (or team) has 'retired' from the match — usually due to injury.
	// The other player (or team) is declared the winner by default.
	MatchUpStatusRetired MatchUpStatus = "RETIRED"
	// The match creation or scheduling is in progress, or it is awaiting final
	// confirmation (e.g., from players or for court availability).
	MatchUpStatusRequested MatchUpStatus = "REQUESTED"
)

var AllMatchUpStatus = []MatchUpStatus{
	MatchUpStatusScheduled,
	MatchUpStatusInProgress,
	MatchUpStatusCompleted,
	MatchUpStatusSuspended,
	MatchUpStatusCancelled,
	MatchUpStatusAbandoned,
	MatchUpStatusRetired,
	MatchUpStatusRequested,
}

func (e MatchUpStatus) IsValid() bool {
	switch e {
	case MatchUpStatusScheduled, MatchUpStatusInProgress, MatchUpStatusCompleted, MatchUpStatusSuspended, MatchUpStatusCancelled, MatchUpStatusAbandoned, MatchUpStatusRetired, MatchUpStatusRequested:
		return true
	}
	return false
}

func (e MatchUpStatus) String() string {
	return string(e)
}

func (e *MatchUpStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpStatus", str)
	}
	return nil
}

func (e MatchUpStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a match is singles (1 vs. 1) or doubles (2 vs. 2).
type MatchUpType string

const (
	// Each side consists of one player.
	MatchUpTypeSingles MatchUpType = "SINGLES"
	// Each side consists of two players.
	MatchUpTypeDoubles MatchUpType = "DOUBLES"
)

var AllMatchUpType = []MatchUpType{
	MatchUpTypeSingles,
	MatchUpTypeDoubles,
}

func (e MatchUpType) IsValid() bool {
	switch e {
	case MatchUpTypeSingles, MatchUpTypeDoubles:
		return true
	}
	return false
}

func (e MatchUpType) String() string {
	return string(e)
}

func (e *MatchUpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpType", str)
	}
	return nil
}

func (e MatchUpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Refers to the physical orientation of the tennis court itself, which could matter
// for sun, wind, or camera placement. For example, a stadium court may label one
// end 'North' and the other end 'South.' Auto assign A as north and B as south
// in the start. Switch the sides after every odd numbered game in a set or every
// 6 points in a tiebreak.
type PhysicalCourtSide string

const (
	// The north side of the court.
	PhysicalCourtSideNorthSide PhysicalCourtSide = "NORTH_SIDE"
	// The south side of the court.
	PhysicalCourtSideSouthSide PhysicalCourtSide = "SOUTH_SIDE"
)

var AllPhysicalCourtSide = []PhysicalCourtSide{
	PhysicalCourtSideNorthSide,
	PhysicalCourtSideSouthSide,
}

func (e PhysicalCourtSide) IsValid() bool {
	switch e {
	case PhysicalCourtSideNorthSide, PhysicalCourtSideSouthSide:
		return true
	}
	return false
}

func (e PhysicalCourtSide) String() string {
	return string(e)
}

func (e *PhysicalCourtSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PhysicalCourtSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PhysicalCourtSide", str)
	}
	return nil
}

func (e PhysicalCourtSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PointWinReason string

const (
	PointWinReasonAce           PointWinReason = "ACE"
	PointWinReasonWinner        PointWinReason = "WINNER"
	PointWinReasonForcedError   PointWinReason = "FORCED_ERROR"
	PointWinReasonUnforcedError PointWinReason = "UNFORCED_ERROR"
	PointWinReasonDoubleFault   PointWinReason = "DOUBLE_FAULT"
)

var AllPointWinReason = []PointWinReason{
	PointWinReasonAce,
	PointWinReasonWinner,
	PointWinReasonForcedError,
	PointWinReasonUnforcedError,
	PointWinReasonDoubleFault,
}

func (e PointWinReason) IsValid() bool {
	switch e {
	case PointWinReasonAce, PointWinReasonWinner, PointWinReasonForcedError, PointWinReasonUnforcedError, PointWinReasonDoubleFault:
		return true
	}
	return false
}

func (e PointWinReason) String() string {
	return string(e)
}

func (e *PointWinReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PointWinReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PointWinReason", str)
	}
	return nil
}

func (e PointWinReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServeStyle string

const (
	ServeStyleFlat  ServeStyle = "FLAT"
	ServeStyleKick  ServeStyle = "KICK"
	ServeStyleSlice ServeStyle = "SLICE"
	ServeStyleOther ServeStyle = "OTHER"
)

var AllServeStyle = []ServeStyle{
	ServeStyleFlat,
	ServeStyleKick,
	ServeStyleSlice,
	ServeStyleOther,
}

func (e ServeStyle) IsValid() bool {
	switch e {
	case ServeStyleFlat, ServeStyleKick, ServeStyleSlice, ServeStyleOther:
		return true
	}
	return false
}

func (e ServeStyle) String() string {
	return string(e)
}

func (e *ServeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServeStyle", str)
	}
	return nil
}

func (e ServeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents which service box a player is serving into or standing on
// during a tennis point. From the server's perspective:
// - The DEUCE_SIDE is on the right side.
// - The AD_SIDE is on the left side.
type ServiceBoxSide string

const (
	// The right side from the server's perspective, commonly called the 'deuce side'.
	ServiceBoxSideDeuceSide ServiceBoxSide = "DEUCE_SIDE"
	// The left side from the server's perspective, commonly called the 'ad side'.
	ServiceBoxSideAdSide ServiceBoxSide = "AD_SIDE"
)

var AllServiceBoxSide = []ServiceBoxSide{
	ServiceBoxSideDeuceSide,
	ServiceBoxSideAdSide,
}

func (e ServiceBoxSide) IsValid() bool {
	switch e {
	case ServiceBoxSideDeuceSide, ServiceBoxSideAdSide:
		return true
	}
	return false
}

func (e ServiceBoxSide) String() string {
	return string(e)
}

func (e *ServiceBoxSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceBoxSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceBoxSide", str)
	}
	return nil
}

func (e ServiceBoxSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ShotType string

const (
	ShotTypeServe        ShotType = "SERVE"
	ShotTypeGroundStroke ShotType = "GROUND_STROKE"
	ShotTypeVolley       ShotType = "VOLLEY"
)

var AllShotType = []ShotType{
	ShotTypeServe,
	ShotTypeGroundStroke,
	ShotTypeVolley,
}

func (e ShotType) IsValid() bool {
	switch e {
	case ShotTypeServe, ShotTypeGroundStroke, ShotTypeVolley:
		return true
	}
	return false
}

func (e ShotType) String() string {
	return string(e)
}

func (e *ShotType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShotType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShotType", str)
	}
	return nil
}

func (e ShotType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates which 'team side' a participant belongs to in a tennis match.
// For instance, in a doubles match, one side may be labeled Team A vs. Team B.
type TeamSide string

const (
	// The 'A' team side.
	TeamSideTeamA TeamSide = "TEAM_A"
	// The 'B' team side.
	TeamSideTeamB TeamSide = "TEAM_B"
)

var AllTeamSide = []TeamSide{
	TeamSideTeamA,
	TeamSideTeamB,
}

func (e TeamSide) IsValid() bool {
	switch e {
	case TeamSideTeamA, TeamSideTeamB:
		return true
	}
	return false
}

func (e TeamSide) String() string {
	return string(e)
}

func (e *TeamSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamSide", str)
	}
	return nil
}

func (e TeamSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPublic  Visibility = "PUBLIC"
	VisibilityPrivate Visibility = "PRIVATE"
	VisibilityFriends Visibility = "FRIENDS"
	VisibilityCoaches Visibility = "COACHES"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityPrivate,
	VisibilityFriends,
	VisibilityCoaches,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityPrivate, VisibilityFriends, VisibilityCoaches:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
