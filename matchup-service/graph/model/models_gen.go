// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"
)

type MatchUp struct {
	ID                  string         `json:"id"`
	MatchUpFormat       *MatchUpFormat `json:"matchUpFormat"`
	MatchUpStatus       MatchUpStatus  `json:"matchUpStatus"`
	MatchUpType         MatchUpType    `json:"matchUpType"`
	Participants        []*Participant `json:"participants"`
	CurrentSetIndex     *int           `json:"currentSetIndex,omitempty"`
	CurrentSetGameIndex *int           `json:"currentSetGameIndex,omitempty"`
	CurrentScore        *Score         `json:"currentScore,omitempty"`
	CurrentServer       PlayingSide    `json:"currentServer"`
	Points              []*Point       `json:"points"`
	PointsSequence      [][][]*Point   `json:"pointsSequence"`
	StartTime           time.Time      `json:"startTime"`
	EndTime             *time.Time     `json:"endTime,omitempty"`
	LastUpdated         time.Time      `json:"lastUpdated"`
}

type MatchUpFormat struct {
	ID             string       `json:"id"`
	NumberOfSets   NumberOfSets `json:"numberOfSets"`
	SetFormat      *SetFormat   `json:"setFormat"`
	FinalSetFormat *SetFormat   `json:"finalSetFormat,omitempty"`
	InitialServer  PlayingSide  `json:"initialServer"`
}

type MatchUpFormatInput struct {
	NumberOfSets   NumberOfSets    `json:"numberOfSets"`
	SetFormat      *SetFormatInput `json:"setFormat"`
	FinalSetFormat *SetFormatInput `json:"finalSetFormat,omitempty"`
}

type Mutation struct {
}

type Participant struct {
	ID          string      `json:"id"`
	PlayingSide PlayingSide `json:"playingSide"`
}

type Point struct {
	ID          string         `json:"id"`
	MatchUpID   string         `json:"matchUpId"`
	SetIndex    int            `json:"setIndex"`
	GameIndex   int            `json:"gameIndex"`
	PointIndex  int            `json:"pointIndex"`
	ServingSide PlayingSide    `json:"servingSide"`
	WinningSide PlayingSide    `json:"winningSide"`
	Timestamp   time.Time      `json:"timestamp"`
	Metadata    *PointMetadata `json:"metadata"`
}

type PointMetadata struct {
	IsBreakPoint    bool `json:"isBreakPoint"`
	IsGamePoint     bool `json:"isGamePoint"`
	IsSetPoint      bool `json:"isSetPoint"`
	IsMatchPoint    bool `json:"isMatchPoint"`
	IsTiebreak      bool `json:"isTiebreak"`
	TiebreakPoint   *int `json:"tiebreakPoint,omitempty"`
	IsDecidingPoint bool `json:"isDecidingPoint"`
	Duration        *int `json:"duration,omitempty"`
	RallyLength     int  `json:"rallyLength"`
}

type Query struct {
}

type Score struct {
	SideA       *SideScore `json:"sideA"`
	SideB       *SideScore `json:"sideB"`
	LastUpdated time.Time  `json:"lastUpdated"`
}

type SetFormat struct {
	NumberOfGames  NumberOfGames   `json:"numberOfGames"`
	DeuceType      DeuceType       `json:"deuceType"`
	MustWinByTwo   bool            `json:"mustWinByTwo"`
	TiebreakFormat *TiebreakFormat `json:"tiebreakFormat,omitempty"`
	TiebreakAt     *int            `json:"tiebreakAt,omitempty"`
}

type SetFormatInput struct {
	NumberOfGames  NumberOfGames        `json:"numberOfGames"`
	DeuceType      DeuceType            `json:"deuceType"`
	MustWinByTwo   bool                 `json:"mustWinByTwo"`
	TiebreakFormat *TiebreakFormatInput `json:"tiebreakFormat,omitempty"`
	TiebreakAt     *int                 `json:"tiebreakAt,omitempty"`
}

type SideScore struct {
	CurrentGameScore     GameScore `json:"currentGameScore"`
	CurrentSetScore      int       `json:"currentSetScore"`
	CurrentTiebreakScore *int      `json:"currentTiebreakScore,omitempty"`
}

type TiebreakFormat struct {
	Points       TiebreakPoints `json:"points"`
	MustWinByTwo bool           `json:"mustWinByTwo"`
}

type TiebreakFormatInput struct {
	Points       TiebreakPoints `json:"points"`
	MustWinByTwo bool           `json:"mustWinByTwo"`
}

type DeuceType string

const (
	DeuceTypeSuddenDeath DeuceType = "SUDDEN_DEATH"
	DeuceTypeNormalDeuce DeuceType = "NORMAL_DEUCE"
	DeuceTypeOneDeuce    DeuceType = "ONE_DEUCE"
)

var AllDeuceType = []DeuceType{
	DeuceTypeSuddenDeath,
	DeuceTypeNormalDeuce,
	DeuceTypeOneDeuce,
}

func (e DeuceType) IsValid() bool {
	switch e {
	case DeuceTypeSuddenDeath, DeuceTypeNormalDeuce, DeuceTypeOneDeuce:
		return true
	}
	return false
}

func (e DeuceType) String() string {
	return string(e)
}

func (e *DeuceType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeuceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeuceType", str)
	}
	return nil
}

func (e DeuceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GameScore string

const (
	GameScoreLove      GameScore = "LOVE"
	GameScoreFifteen   GameScore = "FIFTEEN"
	GameScoreThirty    GameScore = "THIRTY"
	GameScoreForty     GameScore = "FORTY"
	GameScoreAdvantage GameScore = "ADVANTAGE"
)

var AllGameScore = []GameScore{
	GameScoreLove,
	GameScoreFifteen,
	GameScoreThirty,
	GameScoreForty,
	GameScoreAdvantage,
}

func (e GameScore) IsValid() bool {
	switch e {
	case GameScoreLove, GameScoreFifteen, GameScoreThirty, GameScoreForty, GameScoreAdvantage:
		return true
	}
	return false
}

func (e GameScore) String() string {
	return string(e)
}

func (e *GameScore) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GameScore(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GameScore", str)
	}
	return nil
}

func (e GameScore) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchUpStatus string

const (
	MatchUpStatusScheduled  MatchUpStatus = "SCHEDULED"
	MatchUpStatusInProgress MatchUpStatus = "IN_PROGRESS"
	MatchUpStatusCompleted  MatchUpStatus = "COMPLETED"
	MatchUpStatusSuspended  MatchUpStatus = "SUSPENDED"
	MatchUpStatusCancelled  MatchUpStatus = "CANCELLED"
	MatchUpStatusAbandoned  MatchUpStatus = "ABANDONED"
	MatchUpStatusRetired    MatchUpStatus = "RETIRED"
	MatchUpStatusWalkover   MatchUpStatus = "WALKOVER"
	MatchUpStatusNotPlayed  MatchUpStatus = "NOT_PLAYED"
	MatchUpStatusRequested  MatchUpStatus = "REQUESTED"
)

var AllMatchUpStatus = []MatchUpStatus{
	MatchUpStatusScheduled,
	MatchUpStatusInProgress,
	MatchUpStatusCompleted,
	MatchUpStatusSuspended,
	MatchUpStatusCancelled,
	MatchUpStatusAbandoned,
	MatchUpStatusRetired,
	MatchUpStatusWalkover,
	MatchUpStatusNotPlayed,
	MatchUpStatusRequested,
}

func (e MatchUpStatus) IsValid() bool {
	switch e {
	case MatchUpStatusScheduled, MatchUpStatusInProgress, MatchUpStatusCompleted, MatchUpStatusSuspended, MatchUpStatusCancelled, MatchUpStatusAbandoned, MatchUpStatusRetired, MatchUpStatusWalkover, MatchUpStatusNotPlayed, MatchUpStatusRequested:
		return true
	}
	return false
}

func (e MatchUpStatus) String() string {
	return string(e)
}

func (e *MatchUpStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpStatus", str)
	}
	return nil
}

func (e MatchUpStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type MatchUpType string

const (
	MatchUpTypeSingles MatchUpType = "SINGLES"
	MatchUpTypeDoubles MatchUpType = "DOUBLES"
)

var AllMatchUpType = []MatchUpType{
	MatchUpTypeSingles,
	MatchUpTypeDoubles,
}

func (e MatchUpType) IsValid() bool {
	switch e {
	case MatchUpTypeSingles, MatchUpTypeDoubles:
		return true
	}
	return false
}

func (e MatchUpType) String() string {
	return string(e)
}

func (e *MatchUpType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpType", str)
	}
	return nil
}

func (e MatchUpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NumberOfGames string

const (
	NumberOfGamesOne   NumberOfGames = "ONE"
	NumberOfGamesTwo   NumberOfGames = "TWO"
	NumberOfGamesThree NumberOfGames = "THREE"
	NumberOfGamesFour  NumberOfGames = "FOUR"
	NumberOfGamesFive  NumberOfGames = "FIVE"
	NumberOfGamesSix   NumberOfGames = "SIX"
	NumberOfGamesSeven NumberOfGames = "SEVEN"
	NumberOfGamesEight NumberOfGames = "EIGHT"
	NumberOfGamesNine  NumberOfGames = "NINE"
	NumberOfGamesTen   NumberOfGames = "TEN"
)

var AllNumberOfGames = []NumberOfGames{
	NumberOfGamesOne,
	NumberOfGamesTwo,
	NumberOfGamesThree,
	NumberOfGamesFour,
	NumberOfGamesFive,
	NumberOfGamesSix,
	NumberOfGamesSeven,
	NumberOfGamesEight,
	NumberOfGamesNine,
	NumberOfGamesTen,
}

func (e NumberOfGames) IsValid() bool {
	switch e {
	case NumberOfGamesOne, NumberOfGamesTwo, NumberOfGamesThree, NumberOfGamesFour, NumberOfGamesFive, NumberOfGamesSix, NumberOfGamesSeven, NumberOfGamesEight, NumberOfGamesNine, NumberOfGamesTen:
		return true
	}
	return false
}

func (e NumberOfGames) String() string {
	return string(e)
}

func (e *NumberOfGames) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NumberOfGames(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NumberOfGames", str)
	}
	return nil
}

func (e NumberOfGames) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type NumberOfSets string

const (
	NumberOfSetsOne   NumberOfSets = "ONE"
	NumberOfSetsThree NumberOfSets = "THREE"
	NumberOfSetsFive  NumberOfSets = "FIVE"
)

var AllNumberOfSets = []NumberOfSets{
	NumberOfSetsOne,
	NumberOfSetsThree,
	NumberOfSetsFive,
}

func (e NumberOfSets) IsValid() bool {
	switch e {
	case NumberOfSetsOne, NumberOfSetsThree, NumberOfSetsFive:
		return true
	}
	return false
}

func (e NumberOfSets) String() string {
	return string(e)
}

func (e *NumberOfSets) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = NumberOfSets(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid NumberOfSets", str)
	}
	return nil
}

func (e NumberOfSets) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlayingSide string

const (
	PlayingSideA PlayingSide = "A"
	PlayingSideB PlayingSide = "B"
)

var AllPlayingSide = []PlayingSide{
	PlayingSideA,
	PlayingSideB,
}

func (e PlayingSide) IsValid() bool {
	switch e {
	case PlayingSideA, PlayingSideB:
		return true
	}
	return false
}

func (e PlayingSide) String() string {
	return string(e)
}

func (e *PlayingSide) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlayingSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlayingSide", str)
	}
	return nil
}

func (e PlayingSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PointWinReason string

const (
	PointWinReasonAce           PointWinReason = "ACE"
	PointWinReasonWinner        PointWinReason = "WINNER"
	PointWinReasonForcedError   PointWinReason = "FORCED_ERROR"
	PointWinReasonUnforcedError PointWinReason = "UNFORCED_ERROR"
	PointWinReasonError         PointWinReason = "ERROR"
	PointWinReasonDoubleFault   PointWinReason = "DOUBLE_FAULT"
)

var AllPointWinReason = []PointWinReason{
	PointWinReasonAce,
	PointWinReasonWinner,
	PointWinReasonForcedError,
	PointWinReasonUnforcedError,
	PointWinReasonError,
	PointWinReasonDoubleFault,
}

func (e PointWinReason) IsValid() bool {
	switch e {
	case PointWinReasonAce, PointWinReasonWinner, PointWinReasonForcedError, PointWinReasonUnforcedError, PointWinReasonError, PointWinReasonDoubleFault:
		return true
	}
	return false
}

func (e PointWinReason) String() string {
	return string(e)
}

func (e *PointWinReason) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PointWinReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PointWinReason", str)
	}
	return nil
}

func (e PointWinReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TiebreakPoints string

const (
	TiebreakPointsFive  TiebreakPoints = "FIVE"
	TiebreakPointsSix   TiebreakPoints = "SIX"
	TiebreakPointsSeven TiebreakPoints = "SEVEN"
	TiebreakPointsEight TiebreakPoints = "EIGHT"
	TiebreakPointsNine  TiebreakPoints = "NINE"
	TiebreakPointsTen   TiebreakPoints = "TEN"
)

var AllTiebreakPoints = []TiebreakPoints{
	TiebreakPointsFive,
	TiebreakPointsSix,
	TiebreakPointsSeven,
	TiebreakPointsEight,
	TiebreakPointsNine,
	TiebreakPointsTen,
}

func (e TiebreakPoints) IsValid() bool {
	switch e {
	case TiebreakPointsFive, TiebreakPointsSix, TiebreakPointsSeven, TiebreakPointsEight, TiebreakPointsNine, TiebreakPointsTen:
		return true
	}
	return false
}

func (e TiebreakPoints) String() string {
	return string(e)
}

func (e *TiebreakPoints) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TiebreakPoints(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TiebreakPoints", str)
	}
	return nil
}

func (e TiebreakPoints) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
