// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/CourtIQ/courtiq-backend/matchup-service/graph/schema/scalars"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Input for adding a completed point to a match.
// This typically updates the scoreboard, ends the rally,
// and records who won the point and how.
type AddPointInput struct {
	// Which match we're adding a point to.
	MatchUpID string `json:"matchUpId" bson:"matchUpId"`
	// Which team side won the point.
	Winner TeamSide `json:"winner" bson:"winner"`
	// The reason for the point being won
	// (e.g., ACE, FORCED_ERROR, etc.).
	WinReason *PointWinReason `json:"winReason,omitempty" bson:"winReason,omitempty"`
	// Optional: An array of shots (SERVE, FOREHAND, etc.) that
	// led up to this point. Some apps only pass the final shot,
	// or pass them all if you recorded the entire rally.
	Shots []*AddShotInput `json:"shots,omitempty" bson:"shots,omitempty"`
}

// Input for adding a single shot to an existing in-progress point.
// Some shots do not end the point or change the score
// (e.g., a rally shot in mid-point).
type AddShotInput struct {
	// Basic category of shot: SERVE, GROUND_STROKE, or VOLLEY, etc.
	ShotType ShotType `json:"shotType" bson:"shotType"`
	// If GROUND_STROKE: FOREHAND/BACKHAND.
	// Otherwise null.
	GroundStrokeType *GroundStrokeType `json:"groundStrokeType,omitempty" bson:"groundStrokeType,omitempty"`
	// If GROUND_STROKE: SLICE, TOPSPIN, etc.
	// Otherwise null.
	GroundStrokeStyle *GroundStrokeStyle `json:"groundStrokeStyle,omitempty" bson:"groundStrokeStyle,omitempty"`
	// If SERVE: FLAT, KICK, SLICE, or OTHER.
	// Otherwise null.
	ServeStyle *ServeStyle `json:"serveStyle,omitempty" bson:"serveStyle,omitempty"`
}

// Used to create a new tennis match with the specified type, format, and participants.
// If 'visibility' is not provided, it defaults to 'PRIVATE'.
type InitiateMatchUpInput struct {
	// The type of match, e.g., SINGLES or DOUBLES.
	MatchUpType MatchUpType `json:"matchUpType" bson:"matchUpType"`
	// The format and rules for this match (sets, tiebreak details, etc.).
	MatchUpFormat *MatchUpFormatInput `json:"matchUpFormat" bson:"matchUpFormat"`
	// The players or teams participating in the match.
	Participants []*ParticipantInput `json:"participants" bson:"participants"`
	// A reference or ID used to track/log this match (e.g., analytics or
	// a parent entity).
	MatchUpTracker primitive.ObjectID `json:"matchUpTracker" bson:"matchUpTracker"`
	// The participant (by ObjectID) who will serve first.
	InitialServer primitive.ObjectID `json:"initialServer" bson:"initialServer"`
	// Determines who can view or access details of the match; defaults to PRIVATE.
	Visibility *Visibility `json:"visibility,omitempty" bson:"visibility,omitempty"`
}

// Provides structured geographical details about a user's location.
// All fields are optional and can be omitted if unknown.
type Location struct {
	City      *string  `json:"city,omitempty" bson:"city,omitempty"`
	State     *string  `json:"state,omitempty" bson:"state,omitempty"`
	Country   *string  `json:"country,omitempty" bson:"country,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" bson:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" bson:"longitude,omitempty"`
}

type MatchUp struct {
	ID                 primitive.ObjectID `json:"id" bson:"_id"`
	Owner              primitive.ObjectID `json:"owner" bson:"owner"`
	MatchUpFormat      *MatchUpFormat     `json:"matchUpFormat" bson:"matchUpFormat"`
	MatchUpTracker     primitive.ObjectID `json:"matchUpTracker" bson:"matchUpTracker"`
	MatchUpType        MatchUpType        `json:"matchUpType" bson:"matchUpType"`
	MatchUpStatus      MatchUpStatus      `json:"matchUpStatus" bson:"matchUpStatus"`
	Participants       []*Participant     `json:"participants" bson:"participants"`
	InitialServer      primitive.ObjectID `json:"initialServer" bson:"initialServer"`
	CurrentServer      primitive.ObjectID `json:"currentServer" bson:"currentServer"`
	CurrentServingSide TeamSide           `json:"currentServingSide" bson:"currentServingSide"`
	Points             []*MatchUpPoint    `json:"points" bson:"points"`
	Winner             *TeamSide          `json:"winner,omitempty" bson:"winner,omitempty"`
	Loser              *TeamSide          `json:"loser,omitempty" bson:"loser,omitempty"`
	CurrentScore       *MatchUpScore      `json:"currentScore,omitempty" bson:"currentScore,omitempty"`
	ScheduledStartTime *time.Time         `json:"scheduledStartTime,omitempty" bson:"scheduledStartTime,omitempty"`
	StartTime          *time.Time         `json:"startTime,omitempty" bson:"startTime,omitempty"`
	EndTime            *time.Time         `json:"endTime,omitempty" bson:"endTime,omitempty"`
	CreatedAt          time.Time          `json:"createdAt" bson:"createdAt"`
	LastUpdated        time.Time          `json:"lastUpdated" bson:"lastUpdated"`
	Visibility         Visibility         `json:"visibility" bson:"visibility"`
}

// Overall "ruleset" of a tennis match:
// - Total sets (NumberOfSets)
// - Format details for each set
// - Optional alternate final set format
type MatchUpFormat struct {
	// How many sets will be played, restricted by the NumberOfSets scalar.
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// Default set format (e.g., games needed, deuce rules, etc.).
	SetFormat *SetFormat `json:"setFormat" bson:"setFormat"`
	// Alternate rules for the final set (e.g., 10-point tiebreak).
	// May be null if not used.
	FinalSetFormat *SetFormat `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

// Input representation of MatchUpFormat,
// mirroring the MatchUpFormat type.
type MatchUpFormatInput struct {
	// How many total sets are played, restricted by NumberOfSets (1, 3, 5).
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// The default format for all sets except possibly the final one.
	SetFormat *SetFormatInput `json:"setFormat" bson:"setFormat"`
	// Alternate final set format, e.g., to allow a 10-point tiebreak.
	// Optional (null) if not used.
	FinalSetFormat *SetFormatInput `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

// Represents one completed point in a tennis match.
// Stores high-level details: who won, how, the previous scoreboard,
// and an array of all shots taken during the rally.
type MatchUpPoint struct {
	ID        primitive.ObjectID `json:"id" bson:"_id"`
	MatchUpID primitive.ObjectID `json:"matchUpId" bson:"matchUpId"`
	// Which side ultimately won this point?
	Winner TeamSide `json:"winner" bson:"winner"`
	// Why the winning side prevailed:
	// e.g. ACE, FORCED_ERROR, UNFORCED_ERROR, etc.
	WinReason *PointWinReason `json:"winReason,omitempty" bson:"winReason,omitempty"`
	// The participant (player) who served on this point.
	Server *Participant `json:"server" bson:"server"`
	// A snapshot of the scoreboard right before this point was played.
	// Useful for undo or replay logic.
	ScoreBeforePoint *MatchUpScore `json:"scoreBeforePoint,omitempty" bson:"scoreBeforePoint,omitempty"`
	// When the point ended.
	Timestamp *time.Time `json:"timestamp,omitempty" bson:"timestamp,omitempty"`
	// The sequence of shots during the rally (if any).
	// Could be an empty list if it was, for example, an immediate double fault or ace.
	Shots []*MatchUpShot `json:"shots" bson:"shots"`
}

// The main container for a match's real-time or final scoring data.
// - 'sets' contains an array of completed or in-progress sets.
// - 'isMatchComplete' indicates whether the match is officially decided.
type MatchUpScore struct {
	// A list of set-by-set scoring details.
	// Each SetScore shows how many games each side has won
	// and whether a tiebreak is active or finished.
	Sets []*SetScore `json:"sets" bson:"sets"`
	// Indicates if the match is fully decided. If true, one side has won
	// the required number of sets as defined by the MatchUpFormat.
	IsMatchComplete bool `json:"isMatchComplete" bson:"isMatchComplete"`
}

// Each shot in a single tennis point. Could be a serve, ground stroke, or volley.
// Shot-level details (like the stroke style, serve style, or physical court side)
// are stored here if relevant.
type MatchUpShot struct {
	// Basic category of shot: SERVE, GROUND_STROKE, or VOLLEY.
	ShotType ShotType `json:"shotType" bson:"shotType"`
	// If this is a ground stroke, was it FOREHAND or BACKHAND?
	// Otherwise null.
	GroundStrokeType *GroundStrokeType `json:"groundStrokeType,omitempty" bson:"groundStrokeType,omitempty"`
	// If this is a ground stroke, was it a SLICE, TOPSPIN, FLAT, LOB, etc.?
	// Otherwise null.
	GroundStrokeStyle *GroundStrokeStyle `json:"groundStrokeStyle,omitempty" bson:"groundStrokeStyle,omitempty"`
	// If this is a serve, was it FLAT, KICK, SLICE, or OTHER?
	// Otherwise null.
	ServeStyle *ServeStyle `json:"serveStyle,omitempty" bson:"serveStyle,omitempty"`
	// Which side of the physical court was this shot taken from?
	// Could be relevant for overhead sun, wind, camera angle, etc.
	// If not used, can be null.
	CourtSide *PhysicalCourtSide `json:"courtSide,omitempty" bson:"courtSide,omitempty"`
	// Which service box was targeted or stood on if relevant:
	// AD_SIDE or DEUCE_SIDE.
	// Typically only meaningful for serve or return positions.
	ServiceBoxSide *ServiceBoxSide `json:"serviceBoxSide,omitempty" bson:"serviceBoxSide,omitempty"`
	// When the shot ended.
	Timestamp *time.Time `json:"timestamp,omitempty" bson:"timestamp,omitempty"`
}

type Mutation struct {
}

// Represents an individual participant in a tennis match (could be a singles player
// or one of the doubles players). Each participant is associated with one 'team side'
// (e.g., Team A or Team B).
type Participant struct {
	// A unique identifier for the participant.
	ID string `json:"id" bson:"_id"`
	// The name to be displayed (e.g., on scoreboards or UIs).
	DisplayName string `json:"displayName" bson:"displayName"`
	// The side (A or B) that this participant is associated with.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
}

// Represents the information needed to create or link a participant
// (e.g., a player) in a tennis match. If the participant already exists
// in the database (i.e., a registered user), 'id' should be provided.
// If 'id' is omitted or null, the participant will be treated as a 'guest'
// and stored in a separate guests collection.
type ParticipantInput struct {
	// If provided, this corresponds to an existing user in the database.
	// If omitted or null, the participant is treated as a guest and stored separately.
	ID primitive.ObjectID `json:"id" bson:"_id"`
	// The participant's display name.
	DisplayedName string `json:"displayedName" bson:"displayedName"`
	// The side (TEAM_A or TEAM_B) that this participant will play on.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
}

type Query struct {
}

// Describes a single set's structure:
// - Number of games (NumberOfGames)
// - Deuce rules
// - Tiebreak rules
type SetFormat struct {
	// Number of games to win a set, enforced by the NumberOfGames scalar.
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (Advantage, No-Ad, etc.).
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// If true, a player must lead by two games when at deuce.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// How the tiebreak is handled, if triggered.
	TiebreakFormat *TiebreakFormat `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
}

// Input representation of SetFormat,
// mirroring the SetFormat type.
type SetFormatInput struct {
	// Number of games required to win a set (allowed values: 1, 3, 4, 5, 6, 10).
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (e.g., ADV or NO_AD).
	// This remains required because you must specify some deuce rule.
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// Whether a two-game lead is required to close the set.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// Optional tiebreak specification.
	// If omitted, it implies that no tiebreak is used.
	TiebreakFormat *TiebreakFormatInput `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
}

// Each set in a tennis match. If 'isCompleted' is true,
// one side has won the set (e.g., 6–4 or via a tiebreak).
type SetScore struct {
	// Which set number this represents (e.g., set 1, set 2, etc.).
	// Typically 0-based or 1-based depending on your UI.
	SetIndex int `json:"setIndex" bson:"setIndex"`
	// The scores for both sides in this set, including games won
	// and any tiebreak points.
	Sides []*SideSetScore `json:"sides" bson:"sides"`
	// True if this set has been won by one side (reached the required
	// number of games, or won the tiebreak), otherwise false.
	IsCompleted bool `json:"isCompleted" bson:"isCompleted"`
	// True if a tiebreak is currently underway in this set.
	// False if no tiebreak is needed or it's already completed.
	IsTiebreakActive bool `json:"isTiebreakActive" bson:"isTiebreakActive"`
}

// Holds the game-level data for each side in a single set.
//   - 'gamesWon' shows how many games that side has in this set.
//   - 'tiebreakPoints' (if present) indicates how many points they have
//     in a currently active or completed tiebreak.
//   - 'inGameScore' shows the current point score within an ongoing game
//     (e.g., ZERO, FIFTEEN, THIRTY, FORTY, ADV) if not in a tiebreak.
type SideSetScore struct {
	// Which 'team side' (TEAM_A or TEAM_B) these stats belong to.
	Side TeamSide `json:"side" bson:"side"`
	// How many games this side has won so far in the current set.
	GamesWon int `json:"gamesWon" bson:"gamesWon"`
	// The side's point level in the current game (ZERO, FIFTEEN, etc.).
	// If the match is in a tiebreak, this may be less relevant.
	InGameScore InGameScore `json:"inGameScore" bson:"inGameScore"`
	// The number of tiebreak points this side has, if a tiebreak is
	// active or was recently completed. If no tiebreak, this may be 0 or null.
	TiebreakPoints *int `json:"tiebreakPoints,omitempty" bson:"tiebreakPoints,omitempty"`
}

// Defines how a tiebreak is played:
// - Points needed (TiebreakPoints)
// - Whether a two-point lead is required
type TiebreakFormat struct {
	// How many points are needed to win the tiebreak
	// (allowed values: 5, 6, 7, 8, 9, 10).
	Points string `json:"points" bson:"points"`
	// If true, a two-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// The set score at which a tiebreak starts (commonly 6).
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Input representation of TiebreakFormat,
// mirroring the TiebreakFormat type.
type TiebreakFormatInput struct {
	// Points needed to win the tiebreak (5, 6, 7, 8, 9, or 10).
	Points string `json:"points" bson:"points"`
	// If true, a 2-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// Optional "trigger" at which a tiebreak starts (commonly 6).
	// If omitted or null, no tiebreak is triggered at any game score.
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Specifies the deuce rule, i.e., how a game proceeds once it reaches a 40-40 score.
type DeuceType string

const (
	// Sudden-death format: once the score reaches deuce (40-40),
	// the very next point decides the game — no requirement to win by two points.
	DeuceTypeSuddenDeath DeuceType = "SUDDEN_DEATH"
	// Traditional deuce format: a player must secure a two-point lead to win
	// (i.e., 'advantage' followed by another point).
	DeuceTypeNormalDeuce DeuceType = "NORMAL_DEUCE"
	// One-deuce format: once the score reaches deuce, only one deuce is allowed.
	// After that, the next point wins the game, regardless of any lead requirement.
	DeuceTypeOneDeuce DeuceType = "ONE_DEUCE"
)

var AllDeuceType = []DeuceType{
	DeuceTypeSuddenDeath,
	DeuceTypeNormalDeuce,
	DeuceTypeOneDeuce,
}

func (e DeuceType) IsValid() bool {
	switch e {
	case DeuceTypeSuddenDeath, DeuceTypeNormalDeuce, DeuceTypeOneDeuce:
		return true
	}
	return false
}

func (e DeuceType) String() string {
	return string(e)
}

func (e *DeuceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeuceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeuceType", str)
	}
	return nil
}

func (e DeuceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the style of a ground stroke (forehand or backhand),
// e.g., slice, topspin, flat, etc.
type GroundStrokeStyle string

const (
	// A stroke with a cutting motion that produces backspin on the ball.
	// Often used defensively or for drop shots.
	GroundStrokeStyleSlice GroundStrokeStyle = "SLICE"
	// A stroke with heavy topspin, causing the ball to dip and bounce higher.
	GroundStrokeStyleTopspin GroundStrokeStyle = "TOPSPIN"
	// A relatively straight shot with minimal spin, often used aggressively.
	GroundStrokeStyleFlat GroundStrokeStyle = "FLAT"
	// A high, lofted shot, typically used as a defensive measure to push
	// the opponent back or to clear the net player in doubles.
	GroundStrokeStyleLob GroundStrokeStyle = "LOB"
	// A short shot intended to barely clear the net, forcing the opponent
	// to run forward.
	GroundStrokeStyleDropShot GroundStrokeStyle = "DROP_SHOT"
	// An overhead shot (often called an overhead smash). Usually played
	// when a high ball or lob comes toward the net player.
	GroundStrokeStyleSmash GroundStrokeStyle = "SMASH"
)

var AllGroundStrokeStyle = []GroundStrokeStyle{
	GroundStrokeStyleSlice,
	GroundStrokeStyleTopspin,
	GroundStrokeStyleFlat,
	GroundStrokeStyleLob,
	GroundStrokeStyleDropShot,
	GroundStrokeStyleSmash,
}

func (e GroundStrokeStyle) IsValid() bool {
	switch e {
	case GroundStrokeStyleSlice, GroundStrokeStyleTopspin, GroundStrokeStyleFlat, GroundStrokeStyleLob, GroundStrokeStyleDropShot, GroundStrokeStyleSmash:
		return true
	}
	return false
}

func (e GroundStrokeStyle) String() string {
	return string(e)
}

func (e *GroundStrokeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeStyle", str)
	}
	return nil
}

func (e GroundStrokeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a ground stroke is a forehand or backhand.
type GroundStrokeType string

const (
	// A stroke hit from the dominant side of the body.
	GroundStrokeTypeForehand GroundStrokeType = "FOREHAND"
	// A stroke hit from the non-dominant side of the body (with one or two hands).
	GroundStrokeTypeBackhand GroundStrokeType = "BACKHAND"
)

var AllGroundStrokeType = []GroundStrokeType{
	GroundStrokeTypeForehand,
	GroundStrokeTypeBackhand,
}

func (e GroundStrokeType) IsValid() bool {
	switch e {
	case GroundStrokeTypeForehand, GroundStrokeTypeBackhand:
		return true
	}
	return false
}

func (e GroundStrokeType) String() string {
	return string(e)
}

func (e *GroundStrokeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeType", str)
	}
	return nil
}

func (e GroundStrokeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents a single side's in-game scoring state in traditional tennis.
type InGameScore string

const (
	// 0 points in the current game.
	InGameScoreZero InGameScore = "ZERO"
	// 15 points in the current game.
	InGameScoreFifteen InGameScore = "FIFTEEN"
	// 30 points in the current game.
	InGameScoreThirty InGameScore = "THIRTY"
	// 40 points in the current game.
	InGameScoreForty InGameScore = "FORTY"
	// Advantage. Occurs when both players reach 40.
	InGameScoreAdv InGameScore = "ADV"
)

var AllInGameScore = []InGameScore{
	InGameScoreZero,
	InGameScoreFifteen,
	InGameScoreThirty,
	InGameScoreForty,
	InGameScoreAdv,
}

func (e InGameScore) IsValid() bool {
	switch e {
	case InGameScoreZero, InGameScoreFifteen, InGameScoreThirty, InGameScoreForty, InGameScoreAdv:
		return true
	}
	return false
}

func (e InGameScore) String() string {
	return string(e)
}

func (e *InGameScore) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InGameScore(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InGameScore", str)
	}
	return nil
}

func (e InGameScore) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the different stages or outcomes a tennis match can go through.
type MatchUpStatus string

const (
	// The match is scheduled in advance but has not yet started.
	MatchUpStatusScheduled MatchUpStatus = "SCHEDULED"
	// The match is currently in progress.
	MatchUpStatusInProgress MatchUpStatus = "IN_PROGRESS"
	// The match has ended with a clear result (winner determined).
	MatchUpStatusCompleted MatchUpStatus = "COMPLETED"
	// The match has been paused (e.g., due to weather or other external conditions)
	// and is expected to resume later.
	MatchUpStatusSuspended MatchUpStatus = "SUSPENDED"
	// The match has been canceled and will not be played or resumed.
	MatchUpStatusCancelled MatchUpStatus = "CANCELLED"
	// The match was started but ultimately abandoned partway and will not be completed.
	MatchUpStatusAbandoned MatchUpStatus = "ABANDONED"
	// One player (or team) has 'retired' from the match — usually due to injury.
	// The other player (or team) is declared the winner by default.
	MatchUpStatusRetired MatchUpStatus = "RETIRED"
	// The match creation or scheduling is in progress, or it is awaiting final
	// confirmation (e.g., from players or for court availability).
	MatchUpStatusRequested MatchUpStatus = "REQUESTED"
)

var AllMatchUpStatus = []MatchUpStatus{
	MatchUpStatusScheduled,
	MatchUpStatusInProgress,
	MatchUpStatusCompleted,
	MatchUpStatusSuspended,
	MatchUpStatusCancelled,
	MatchUpStatusAbandoned,
	MatchUpStatusRetired,
	MatchUpStatusRequested,
}

func (e MatchUpStatus) IsValid() bool {
	switch e {
	case MatchUpStatusScheduled, MatchUpStatusInProgress, MatchUpStatusCompleted, MatchUpStatusSuspended, MatchUpStatusCancelled, MatchUpStatusAbandoned, MatchUpStatusRetired, MatchUpStatusRequested:
		return true
	}
	return false
}

func (e MatchUpStatus) String() string {
	return string(e)
}

func (e *MatchUpStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpStatus", str)
	}
	return nil
}

func (e MatchUpStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a match is singles (1 vs. 1) or doubles (2 vs. 2).
type MatchUpType string

const (
	// Each side consists of one player.
	MatchUpTypeSingles MatchUpType = "SINGLES"
	// Each side consists of two players.
	MatchUpTypeDoubles MatchUpType = "DOUBLES"
)

var AllMatchUpType = []MatchUpType{
	MatchUpTypeSingles,
	MatchUpTypeDoubles,
}

func (e MatchUpType) IsValid() bool {
	switch e {
	case MatchUpTypeSingles, MatchUpTypeDoubles:
		return true
	}
	return false
}

func (e MatchUpType) String() string {
	return string(e)
}

func (e *MatchUpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpType", str)
	}
	return nil
}

func (e MatchUpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Refers to the physical orientation of the tennis court itself, which could matter
// for sun, wind, or camera placement. For example, a stadium court may label one
// end 'North' and the other end 'South.' Auto assign A as north and B as south
// in the start. Switch the sides after every odd numbered game in a set or every
// 6 points in a tiebreak.
type PhysicalCourtSide string

const (
	// The north side of the court.
	PhysicalCourtSideNorthSide PhysicalCourtSide = "NORTH_SIDE"
	// The south side of the court.
	PhysicalCourtSideSouthSide PhysicalCourtSide = "SOUTH_SIDE"
)

var AllPhysicalCourtSide = []PhysicalCourtSide{
	PhysicalCourtSideNorthSide,
	PhysicalCourtSideSouthSide,
}

func (e PhysicalCourtSide) IsValid() bool {
	switch e {
	case PhysicalCourtSideNorthSide, PhysicalCourtSideSouthSide:
		return true
	}
	return false
}

func (e PhysicalCourtSide) String() string {
	return string(e)
}

func (e *PhysicalCourtSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PhysicalCourtSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PhysicalCourtSide", str)
	}
	return nil
}

func (e PhysicalCourtSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the main reason why a particular side won a tennis point.
type PointWinReason string

const (
	// The server hit a serve that the opponent could not touch or return.
	PointWinReasonAce PointWinReason = "ACE"
	// A shot that cleanly beats the opponent (not necessarily off the serve).
	PointWinReasonWinner PointWinReason = "WINNER"
	// The opponent was forced into an error by a strong or tricky shot.
	PointWinReasonForcedError PointWinReason = "FORCED_ERROR"
	// The opponent made an unforced error (e.g., an easy miss or unprovoked mistake).
	PointWinReasonUnforcedError PointWinReason = "UNFORCED_ERROR"
	// The server failed to execute a valid serve on both the first and second attempt.
	PointWinReasonDoubleFault PointWinReason = "DOUBLE_FAULT"
)

var AllPointWinReason = []PointWinReason{
	PointWinReasonAce,
	PointWinReasonWinner,
	PointWinReasonForcedError,
	PointWinReasonUnforcedError,
	PointWinReasonDoubleFault,
}

func (e PointWinReason) IsValid() bool {
	switch e {
	case PointWinReasonAce, PointWinReasonWinner, PointWinReasonForcedError, PointWinReasonUnforcedError, PointWinReasonDoubleFault:
		return true
	}
	return false
}

func (e PointWinReason) String() string {
	return string(e)
}

func (e *PointWinReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PointWinReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PointWinReason", str)
	}
	return nil
}

func (e PointWinReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the style of serve (flat, kick, slice, or other).
type ServeStyle string

const (
	// A serve with minimal spin, often very fast and direct.
	ServeStyleFlat ServeStyle = "FLAT"
	// A serve with topspin that causes the ball to jump high upon bouncing.
	ServeStyleKick ServeStyle = "KICK"
	// A serve with sidespin, curving the ball in the air and off the court.
	ServeStyleSlice ServeStyle = "SLICE"
	// Any other specialized serve style (e.g., twist serve),
	// or unclassified serve approach.
	ServeStyleOther ServeStyle = "OTHER"
)

var AllServeStyle = []ServeStyle{
	ServeStyleFlat,
	ServeStyleKick,
	ServeStyleSlice,
	ServeStyleOther,
}

func (e ServeStyle) IsValid() bool {
	switch e {
	case ServeStyleFlat, ServeStyleKick, ServeStyleSlice, ServeStyleOther:
		return true
	}
	return false
}

func (e ServeStyle) String() string {
	return string(e)
}

func (e *ServeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServeStyle", str)
	}
	return nil
}

func (e ServeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents which service box a player is serving into or standing on
// during a tennis point. From the server's perspective:
// - The DEUCE_SIDE is on the right side.
// - The AD_SIDE is on the left side.
type ServiceBoxSide string

const (
	// The right side from the server's perspective, commonly called the 'deuce side'.
	ServiceBoxSideDeuceSide ServiceBoxSide = "DEUCE_SIDE"
	// The left side from the server's perspective, commonly called the 'ad side'.
	ServiceBoxSideAdSide ServiceBoxSide = "AD_SIDE"
)

var AllServiceBoxSide = []ServiceBoxSide{
	ServiceBoxSideDeuceSide,
	ServiceBoxSideAdSide,
}

func (e ServiceBoxSide) IsValid() bool {
	switch e {
	case ServiceBoxSideDeuceSide, ServiceBoxSideAdSide:
		return true
	}
	return false
}

func (e ServiceBoxSide) String() string {
	return string(e)
}

func (e *ServiceBoxSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceBoxSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceBoxSide", str)
	}
	return nil
}

func (e ServiceBoxSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Categorizes the type of shot in a rally.
type ShotType string

const (
	// The initial shot to start a point. Can be first or second serve.
	ShotTypeServe ShotType = "SERVE"
	// A shot hit after the serve, typically from the baseline (forehand or backhand).
	ShotTypeGroundStroke ShotType = "GROUND_STROKE"
	// A shot taken near the net, without the ball bouncing (e.g., a volley or half-volley).
	ShotTypeVolley ShotType = "VOLLEY"
)

var AllShotType = []ShotType{
	ShotTypeServe,
	ShotTypeGroundStroke,
	ShotTypeVolley,
}

func (e ShotType) IsValid() bool {
	switch e {
	case ShotTypeServe, ShotTypeGroundStroke, ShotTypeVolley:
		return true
	}
	return false
}

func (e ShotType) String() string {
	return string(e)
}

func (e *ShotType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShotType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShotType", str)
	}
	return nil
}

func (e ShotType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates which 'team side' a participant belongs to in a tennis match.
// For instance, in a doubles match, one side may be labeled Team A vs. Team B.
type TeamSide string

const (
	// The 'A' team side.
	TeamSideTeamA TeamSide = "TEAM_A"
	// The 'B' team side.
	TeamSideTeamB TeamSide = "TEAM_B"
)

var AllTeamSide = []TeamSide{
	TeamSideTeamA,
	TeamSideTeamB,
}

func (e TeamSide) IsValid() bool {
	switch e {
	case TeamSideTeamA, TeamSideTeamB:
		return true
	}
	return false
}

func (e TeamSide) String() string {
	return string(e)
}

func (e *TeamSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamSide", str)
	}
	return nil
}

func (e TeamSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPublic  Visibility = "PUBLIC"
	VisibilityPrivate Visibility = "PRIVATE"
	VisibilityFriends Visibility = "FRIENDS"
	VisibilityCoaches Visibility = "COACHES"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityPrivate,
	VisibilityFriends,
	VisibilityCoaches,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityPrivate, VisibilityFriends, VisibilityCoaches:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
