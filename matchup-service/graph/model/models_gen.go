// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/CourtIQ/courtiq-backend/matchup-service/graph/schema/scalars"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Input for adding a new shot to a tennis match.
// The backend will handle score calculation and state updates.
type AddShotInput struct {
	// The match ID this shot belongs to.
	MatchUpID primitive.ObjectID `json:"matchUpId" bson:"matchUpId"`
	// ID of the player who hit this shot.
	HitterID primitive.ObjectID `json:"hitterId" bson:"hitterId"`
	// Type of shot (serve, ground stroke, volley).
	ShotType ShotType `json:"shotType" bson:"shotType"`
	// For ground strokes, specifies forehand or backhand.
	// Only required when shotType is GROUND_STROKE.
	GroundStrokeType *GroundStrokeType `json:"groundStrokeType,omitempty" bson:"groundStrokeType,omitempty"`
	// Style of ground stroke (topspin, slice, etc).
	// Only applicable when shotType is GROUND_STROKE.
	GroundStrokeStyle *GroundStrokeStyle `json:"groundStrokeStyle,omitempty" bson:"groundStrokeStyle,omitempty"`
	// Style of serve (flat, kick, slice).
	// Only applicable when shotType is SERVE.
	ServeStyle *ServeStyle `json:"serveStyle,omitempty" bson:"serveStyle,omitempty"`
	// Whether this is a first or second serve attempt.
	// Only applicable when shotType is SERVE.
	ServeNumber *ServeNumber `json:"serveNumber,omitempty" bson:"serveNumber,omitempty"`
	// Which service box the serve was directed to.
	// Only applicable when shotType is SERVE.
	ServiceBoxSide *ServiceBoxSide `json:"serviceBoxSide,omitempty" bson:"serviceBoxSide,omitempty"`
	// The outcome of this specific shot.
	ShotOutcome ShotOutcome `json:"shotOutcome" bson:"shotOutcome"`
	// If this shot won the point, specifies how.
	// Only applicable when shotOutcome is WON_POINT.
	PointWinReason *PointWinReason `json:"pointWinReason,omitempty" bson:"pointWinReason,omitempty"`
}

// Used to create a new tennis match with the specified type, format, and participants.
// If 'visibility' is not provided, it defaults to 'PRIVATE'.
type InitiateMatchUpInput struct {
	// The type of match, e.g., SINGLES or DOUBLES.
	MatchUpType MatchUpType `json:"matchUpType" bson:"matchUpType"`
	// The format and rules for this match (sets, tiebreak details, etc.).
	MatchUpFormat *MatchUpFormatInput `json:"matchUpFormat" bson:"matchUpFormat"`
	// The players or teams participating in the match.
	Participants []*ParticipantInput `json:"participants" bson:"participants"`
	// A person who might not be a participant in a match but is helping to track it.
	MatchUpTracker primitive.ObjectID `json:"matchUpTracker" bson:"matchUpTracker"`
	// The participant (by ObjectID) who will serve first.
	InitialServer primitive.ObjectID `json:"initialServer" bson:"initialServer"`
	// The style of tracking make used to record match data.
	TrackingStyle *MatchUpTrackingStyle `json:"trackingStyle,omitempty" bson:"trackingStyle,omitempty"`
}

// Provides structured geographical details about a user's location.
// All fields are optional and can be omitted if unknown.
type Location struct {
	City      *string  `json:"city,omitempty" bson:"city,omitempty"`
	State     *string  `json:"state,omitempty" bson:"state,omitempty"`
	Country   *string  `json:"country,omitempty" bson:"country,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" bson:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" bson:"longitude,omitempty"`
}

// Snapshot of the match state after a shot was played.
type MatchStateSnapshot struct {
	// Current score state after this shot.
	Score *MatchUpScore `json:"score" bson:"score"`
	// True if this shot completed a point.
	PointCompleted bool `json:"pointCompleted" bson:"pointCompleted"`
	// True if this shot completed a game.
	GameCompleted bool `json:"gameCompleted" bson:"gameCompleted"`
	// True if this shot completed a set.
	SetCompleted bool `json:"setCompleted" bson:"setCompleted"`
	// True if this shot completed the match.
	MatchCompleted bool `json:"matchCompleted" bson:"matchCompleted"`
	// If the point was completed, which team won it.
	PointWinner *TeamSide `json:"pointWinner,omitempty" bson:"pointWinner,omitempty"`
}

type MatchUp struct {
	ID                 primitive.ObjectID  `json:"id" bson:"_id"`
	Owner              primitive.ObjectID  `json:"owner" bson:"owner"`
	MatchUpFormat      *MatchUpFormat      `json:"matchUpFormat" bson:"matchUpFormat"`
	MatchUpTracker     primitive.ObjectID  `json:"matchUpTracker" bson:"matchUpTracker"`
	MatchUpType        MatchUpType         `json:"matchUpType" bson:"matchUpType"`
	MatchUpStatus      MatchUpStatus       `json:"matchUpStatus" bson:"matchUpStatus"`
	Participants       []*Participant      `json:"participants" bson:"participants"`
	InitialServer      primitive.ObjectID  `json:"initialServer" bson:"initialServer"`
	CurrentServer      primitive.ObjectID  `json:"currentServer" bson:"currentServer"`
	CurrentScore       *MatchUpScore       `json:"currentScore" bson:"currentScore"`
	FirstShot          *primitive.ObjectID `json:"firstShot,omitempty" bson:"firstShot,omitempty"`
	LastShot           *primitive.ObjectID `json:"lastShot,omitempty" bson:"lastShot,omitempty"`
	Winner             *TeamSide           `json:"winner,omitempty" bson:"winner,omitempty"`
	Loser              *TeamSide           `json:"loser,omitempty" bson:"loser,omitempty"`
	ScheduledStartTime *time.Time          `json:"scheduledStartTime,omitempty" bson:"scheduledStartTime,omitempty"`
	StartTime          *time.Time          `json:"startTime,omitempty" bson:"startTime,omitempty"`
	EndTime            *time.Time          `json:"endTime,omitempty" bson:"endTime,omitempty"`
	CreatedAt          time.Time           `json:"createdAt" bson:"createdAt"`
	LastUpdated        time.Time           `json:"lastUpdated" bson:"lastUpdated"`
}

// Overall "ruleset" of a tennis match:
// - Total sets (NumberOfSets)
// - Format details for each set
// - Optional alternate final set format
type MatchUpFormat struct {
	// How many sets will be played, restricted by the NumberOfSets scalar.
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// Default set format (e.g., games needed, deuce rules, etc.).
	SetFormat *SetFormat `json:"setFormat" bson:"setFormat"`
	// Alternate rules for the final set (e.g., 10-point tiebreak).
	// May be null if not used.
	FinalSetFormat *SetFormat `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

// Input representation of MatchUpFormat,
// mirroring the MatchUpFormat type.
type MatchUpFormatInput struct {
	// How many total sets are played, restricted by NumberOfSets (1, 3, 5).
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// The default format for all sets except possibly the final one.
	SetFormat *SetFormatInput `json:"setFormat" bson:"setFormat"`
	// Alternate final set format, e.g., to allow a 10-point tiebreak.
	// Optional (null) if not used.
	FinalSetFormat *SetFormatInput `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

// The main container for a match's real-time or final scoring data.
// - 'sets' contains an array of completed or in-progress sets.
// - 'isMatchComplete' indicates whether the match is officially decided.
type MatchUpScore struct {
	// A list of set-by-set scoring details.
	// Each SetScore shows how many games each side has won
	// and whether a tiebreak is active or finished.
	Sets []*SetScore `json:"sets" bson:"sets"`
	// Indicates if the match is fully decided. If true, one side has won
	// the required number of sets as defined by the MatchUpFormat.
	IsMatchComplete bool `json:"isMatchComplete" bson:"isMatchComplete"`
}

// Represents an individual shot in a tennis match, forming a doubly-linked list
// structure that allows for traversal and undo operations. Contains context about
// the point, the shot details, and state changes resulting from the shot.
type MatchUpShot struct {
	// Unique identifier for this shot.
	ID primitive.ObjectID `json:"id" bson:"_id"`
	// Reference to the match this shot belongs to.
	MatchUpID primitive.ObjectID `json:"matchUpId" bson:"matchUpId"`
	// Reference to the previous shot in the sequence (null if first shot).
	PrevShotID *primitive.ObjectID `json:"prevShotId,omitempty" bson:"prevShotId,omitempty"`
	// Reference to the next shot in the sequence (null if most recent shot).
	NextShotID *primitive.ObjectID `json:"nextShotId,omitempty" bson:"nextShotId,omitempty"`
	// Player who hit this shot.
	HitterID primitive.ObjectID `json:"hitterId" bson:"hitterId"`
	// Team side of the player who hit this shot.
	HitterSide TeamSide `json:"hitterSide" bson:"hitterSide"`
	// Type of shot (serve, ground stroke, volley).
	ShotType ShotType `json:"shotType" bson:"shotType"`
	// For ground strokes, specifies forehand or backhand.
	// Only applicable when shotType is GROUND_STROKE.
	GroundStrokeType *GroundStrokeType `json:"groundStrokeType,omitempty" bson:"groundStrokeType,omitempty"`
	// Style of ground stroke (topspin, slice, etc).
	// Only applicable when shotType is GROUND_STROKE.
	GroundStrokeStyle *GroundStrokeStyle `json:"groundStrokeStyle,omitempty" bson:"groundStrokeStyle,omitempty"`
	// Style of serve (flat, kick, slice).
	// Only applicable when shotType is SERVE.
	ServeStyle *ServeStyle `json:"serveStyle,omitempty" bson:"serveStyle,omitempty"`
	// Whether this is a first or second serve attempt.
	// Only applicable when shotType is SERVE.
	ServeNumber *ServeNumber `json:"serveNumber,omitempty" bson:"serveNumber,omitempty"`
	// Which service box the serve was directed to.
	// Only applicable when shotType is SERVE.
	ServiceBoxSide *ServiceBoxSide `json:"serviceBoxSide,omitempty" bson:"serviceBoxSide,omitempty"`
	// The outcome of this specific shot.
	ShotOutcome ShotOutcome `json:"shotOutcome" bson:"shotOutcome"`
	// If this shot won the point, specifies how.
	// Only applicable when shotOutcome is WON_POINT.
	PointWinReason *PointWinReason `json:"pointWinReason,omitempty" bson:"pointWinReason,omitempty"`
	// Special significance of this point, if any.
	PointImportance PointImportance `json:"pointImportance" bson:"pointImportance"`
	// Current point context within the match structure.
	PointContext *PointContext `json:"pointContext" bson:"pointContext"`
	// Score state after this shot.
	MatchStateAfterShot *MatchStateSnapshot `json:"matchStateAfterShot" bson:"matchStateAfterShot"`
	// When this shot occurred.
	Timestamp time.Time `json:"timestamp" bson:"timestamp"`
}

type Mutation struct {
}

// Represents an individual participant in a tennis match (could be a singles player
// or one of the doubles players). Each participant is associated with one 'team side'
// (e.g., Team A or Team B).
type Participant struct {
	// A unique identifier for the participant.
	ID primitive.ObjectID `json:"id" bson:"_id"`
	// The name to be displayed (e.g., on scoreboards or UIs).
	DisplayName string `json:"displayName" bson:"displayName"`
	// The side (A or B) that this participant is associated with.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
	// Optional boolen to store if a participant is a guest or not.
	IsGuest bool `json:"isGuest" bson:"isGuest"`
}

// Represents the information needed to create or link a participant
// (e.g., a player) in a tennis match. If the participant already exists
// in the database (i.e., a registered user), 'id' should be provided.
// If 'id' is omitted or null, the participant will be treated as a 'guest'
// and stored in a separate guests collection.
type ParticipantInput struct {
	// If provided, this corresponds to an existing user in the database.
	// If omitted or null, the participant is treated as a guest and stored separately.
	ID *primitive.ObjectID `json:"id" bson:"_id"`
	// The participant's display name.
	DisplayedName string `json:"displayedName" bson:"displayedName"`
	// The side (TEAM_A or TEAM_B) that this participant will play on.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
}

// Captures the context of a point within a match structure.
type PointContext struct {
	// Current set number (1-based index).
	SetNumber int `json:"setNumber" bson:"setNumber"`
	// Current game number within the set (1-based index).
	GameNumber int `json:"gameNumber" bson:"gameNumber"`
	// Current point number within the game (1-based index).
	PointNumber int `json:"pointNumber" bson:"pointNumber"`
	// ID of the player who is serving.
	ServerID primitive.ObjectID `json:"serverId" bson:"serverId"`
	// Team side of the server.
	ServerSide TeamSide `json:"serverSide" bson:"serverSide"`
	// Which service box is being served to.
	ServiceBoxSide ServiceBoxSide `json:"serviceBoxSide" bson:"serviceBoxSide"`
}

type Query struct {
}

// Describes a single set's structure:
// - Number of games (NumberOfGames)
// - Deuce rules
// - Tiebreak rules
type SetFormat struct {
	// Number of games to win a set, enforced by the NumberOfGames scalar.
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (Advantage, No-Ad, etc.).
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// If true, a player must lead by two games when at deuce.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// How the tiebreak is handled, if triggered.
	TiebreakFormat *TiebreakFormat `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
}

// Input representation of SetFormat,
// mirroring the SetFormat type.
type SetFormatInput struct {
	// Number of games required to win a set (allowed values: 1, 3, 4, 5, 6, 10).
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (e.g., ADV or NO_AD).
	// This remains required because you must specify some deuce rule.
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// Whether a two-game lead is required to close the set.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// Optional tiebreak specification.
	// If omitted, it implies that no tiebreak is used.
	TiebreakFormat *TiebreakFormatInput `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
}

// Each set in a tennis match. If 'isCompleted' is true,
// one side has won the set (e.g., 6–4 or via a tiebreak).
type SetScore struct {
	// Which set number this represents (e.g., set 1, set 2, etc.).
	// This is 1-based.
	SetIndex int `json:"setIndex" bson:"setIndex"`
	// The scores for both sides in this set, including games won
	// and any tiebreak points.
	Sides []*SideSetScore `json:"sides" bson:"sides"`
	// True if this set has been won by one side (reached the required
	// number of games, or won the tiebreak), otherwise false.
	IsCompleted bool `json:"isCompleted" bson:"isCompleted"`
	// True if a tiebreak is currently underway in this set.
	// False if no tiebreak is needed or it's already completed.
	IsTiebreakActive bool `json:"isTiebreakActive" bson:"isTiebreakActive"`
}

// Holds the game-level data for each side in a single set.
//   - 'gamesWon' shows how many games that side has in this set.
//   - 'tiebreakPoints' (if present) indicates how many points they have
//     in a currently active or completed tiebreak.
//   - 'inGameScore' shows the current point score within an ongoing game
//     (e.g., ZERO, FIFTEEN, THIRTY, FORTY, ADV) if not in a tiebreak.
type SideSetScore struct {
	// Which 'team side' (TEAM_A or TEAM_B) these stats belong to.
	Side TeamSide `json:"side" bson:"side"`
	// How many games this side has won so far in the current set.
	GamesWon int `json:"gamesWon" bson:"gamesWon"`
	// The side's point level in the current game (ZERO, FIFTEEN, etc.).
	// If the match is in a tiebreak, this may be less relevant.
	InGameScore InGameScore `json:"inGameScore" bson:"inGameScore"`
	// The number of tiebreak points this side has, if a tiebreak is
	// active or was recently completed. If no tiebreak, this may be 0 or null.
	TiebreakPoints *int `json:"tiebreakPoints,omitempty" bson:"tiebreakPoints,omitempty"`
}

// Defines how a tiebreak is played:
// - Points needed (TiebreakPoints)
// - Whether a two-point lead is required
type TiebreakFormat struct {
	// How many points are needed to win the tiebreak
	// (allowed values: 5, 6, 7, 8, 9, 10).
	Points string `json:"points" bson:"points"`
	// If true, a two-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// The set score at which a tiebreak starts (commonly 6).
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Input representation of TiebreakFormat,
// mirroring the TiebreakFormat type.
type TiebreakFormatInput struct {
	// Points needed to win the tiebreak (5, 6, 7, 8, 9, or 10).
	Points string `json:"points" bson:"points"`
	// If true, a 2-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// Optional "trigger" at which a tiebreak starts (commonly 6).
	TiebreakAt int `json:"tiebreakAt" bson:"tiebreakAt"`
}

// Specifies the deuce rule, i.e., how a game proceeds once it reaches a 40-40 score.
type DeuceType string

const (
	// Sudden-death format: once the score reaches deuce (40-40),
	// the very next point decides the game — no requirement to win by two points.
	DeuceTypeSuddenDeath DeuceType = "SUDDEN_DEATH"
	// Traditional deuce format: a player must secure a two-point lead to win
	// (i.e., 'advantage' followed by another point).
	DeuceTypeNormalDeuce DeuceType = "NORMAL_DEUCE"
	// One-deuce format: once the score reaches deuce, only one deuce is allowed.
	// After that, the next point wins the game, regardless of any lead requirement.
	DeuceTypeOneDeuce DeuceType = "ONE_DEUCE"
)

var AllDeuceType = []DeuceType{
	DeuceTypeSuddenDeath,
	DeuceTypeNormalDeuce,
	DeuceTypeOneDeuce,
}

func (e DeuceType) IsValid() bool {
	switch e {
	case DeuceTypeSuddenDeath, DeuceTypeNormalDeuce, DeuceTypeOneDeuce:
		return true
	}
	return false
}

func (e DeuceType) String() string {
	return string(e)
}

func (e *DeuceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeuceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeuceType", str)
	}
	return nil
}

func (e DeuceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the style of a ground stroke (forehand or backhand),
// e.g., slice, topspin, flat, etc.
type GroundStrokeStyle string

const (
	// A stroke with a cutting motion that produces backspin on the ball.
	// Often used defensively or for drop shots.
	GroundStrokeStyleSlice GroundStrokeStyle = "SLICE"
	// A stroke with heavy topspin, causing the ball to dip and bounce higher.
	GroundStrokeStyleTopspin GroundStrokeStyle = "TOPSPIN"
	// A relatively straight shot with minimal spin, often used aggressively.
	GroundStrokeStyleFlat GroundStrokeStyle = "FLAT"
	// A high, lofted shot, typically used as a defensive measure to push
	// the opponent back or to clear the net player in doubles.
	GroundStrokeStyleLob GroundStrokeStyle = "LOB"
	// A short shot intended to barely clear the net, forcing the opponent
	// to run forward.
	GroundStrokeStyleDropShot GroundStrokeStyle = "DROP_SHOT"
	// An overhead shot (often called an overhead smash). Usually played
	// when a high ball or lob comes toward the net player.
	GroundStrokeStyleSmash GroundStrokeStyle = "SMASH"
)

var AllGroundStrokeStyle = []GroundStrokeStyle{
	GroundStrokeStyleSlice,
	GroundStrokeStyleTopspin,
	GroundStrokeStyleFlat,
	GroundStrokeStyleLob,
	GroundStrokeStyleDropShot,
	GroundStrokeStyleSmash,
}

func (e GroundStrokeStyle) IsValid() bool {
	switch e {
	case GroundStrokeStyleSlice, GroundStrokeStyleTopspin, GroundStrokeStyleFlat, GroundStrokeStyleLob, GroundStrokeStyleDropShot, GroundStrokeStyleSmash:
		return true
	}
	return false
}

func (e GroundStrokeStyle) String() string {
	return string(e)
}

func (e *GroundStrokeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeStyle", str)
	}
	return nil
}

func (e GroundStrokeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a ground stroke is a forehand or backhand.
type GroundStrokeType string

const (
	// A stroke hit from the dominant side of the body.
	GroundStrokeTypeForehand GroundStrokeType = "FOREHAND"
	// A stroke hit from the non-dominant side of the body (with one or two hands).
	GroundStrokeTypeBackhand GroundStrokeType = "BACKHAND"
)

var AllGroundStrokeType = []GroundStrokeType{
	GroundStrokeTypeForehand,
	GroundStrokeTypeBackhand,
}

func (e GroundStrokeType) IsValid() bool {
	switch e {
	case GroundStrokeTypeForehand, GroundStrokeTypeBackhand:
		return true
	}
	return false
}

func (e GroundStrokeType) String() string {
	return string(e)
}

func (e *GroundStrokeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeType", str)
	}
	return nil
}

func (e GroundStrokeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents a single side's in-game scoring state in traditional tennis.
type InGameScore string

const (
	// 0 points in the current game.
	InGameScoreZero InGameScore = "ZERO"
	// 15 points in the current game.
	InGameScoreFifteen InGameScore = "FIFTEEN"
	// 30 points in the current game.
	InGameScoreThirty InGameScore = "THIRTY"
	// 40 points in the current game.
	InGameScoreForty InGameScore = "FORTY"
	// Advantage. Occurs when both players reach 40.
	InGameScoreAdv InGameScore = "ADV"
)

var AllInGameScore = []InGameScore{
	InGameScoreZero,
	InGameScoreFifteen,
	InGameScoreThirty,
	InGameScoreForty,
	InGameScoreAdv,
}

func (e InGameScore) IsValid() bool {
	switch e {
	case InGameScoreZero, InGameScoreFifteen, InGameScoreThirty, InGameScoreForty, InGameScoreAdv:
		return true
	}
	return false
}

func (e InGameScore) String() string {
	return string(e)
}

func (e *InGameScore) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = InGameScore(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid InGameScore", str)
	}
	return nil
}

func (e InGameScore) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the different stages or outcomes a tennis match can go through.
type MatchUpStatus string

const (
	// The match is scheduled in advance but has not yet started.
	MatchUpStatusScheduled MatchUpStatus = "SCHEDULED"
	// The match is currently in progress.
	MatchUpStatusInProgress MatchUpStatus = "IN_PROGRESS"
	// The match has ended with a clear result (winner determined).
	MatchUpStatusCompleted MatchUpStatus = "COMPLETED"
	// The match has been paused (e.g., due to weather or other external conditions)
	// and is expected to resume later.
	MatchUpStatusSuspended MatchUpStatus = "SUSPENDED"
	// The match has been canceled and will not be played or resumed.
	MatchUpStatusCancelled MatchUpStatus = "CANCELLED"
	// The match was started but ultimately abandoned partway and will not be completed.
	MatchUpStatusAbandoned MatchUpStatus = "ABANDONED"
	// One player (or team) has 'retired' from the match — usually due to injury.
	// The other player (or team) is declared the winner by default.
	MatchUpStatusRetired MatchUpStatus = "RETIRED"
	// The match creation or scheduling is in progress, or it is awaiting final
	// confirmation (e.g., from players or for court availability).
	MatchUpStatusRequested MatchUpStatus = "REQUESTED"
)

var AllMatchUpStatus = []MatchUpStatus{
	MatchUpStatusScheduled,
	MatchUpStatusInProgress,
	MatchUpStatusCompleted,
	MatchUpStatusSuspended,
	MatchUpStatusCancelled,
	MatchUpStatusAbandoned,
	MatchUpStatusRetired,
	MatchUpStatusRequested,
}

func (e MatchUpStatus) IsValid() bool {
	switch e {
	case MatchUpStatusScheduled, MatchUpStatusInProgress, MatchUpStatusCompleted, MatchUpStatusSuspended, MatchUpStatusCancelled, MatchUpStatusAbandoned, MatchUpStatusRetired, MatchUpStatusRequested:
		return true
	}
	return false
}

func (e MatchUpStatus) String() string {
	return string(e)
}

func (e *MatchUpStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpStatus", str)
	}
	return nil
}

func (e MatchUpStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates different levels of tracking complexity or granularity.
type MatchUpTrackingStyle string

const (
	// Basic minimal tracking.
	MatchUpTrackingStyleBeginner MatchUpTrackingStyle = "BEGINNER"
	// Moderately detailed tracking.
	MatchUpTrackingStyleIntermediate MatchUpTrackingStyle = "INTERMEDIATE"
	// Most detailed tracking, for power users or deep analysis.
	MatchUpTrackingStyleAdvanced MatchUpTrackingStyle = "ADVANCED"
)

var AllMatchUpTrackingStyle = []MatchUpTrackingStyle{
	MatchUpTrackingStyleBeginner,
	MatchUpTrackingStyleIntermediate,
	MatchUpTrackingStyleAdvanced,
}

func (e MatchUpTrackingStyle) IsValid() bool {
	switch e {
	case MatchUpTrackingStyleBeginner, MatchUpTrackingStyleIntermediate, MatchUpTrackingStyleAdvanced:
		return true
	}
	return false
}

func (e MatchUpTrackingStyle) String() string {
	return string(e)
}

func (e *MatchUpTrackingStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpTrackingStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpTrackingStyle", str)
	}
	return nil
}

func (e MatchUpTrackingStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a match is singles (1 vs. 1) or doubles (2 vs. 2).
type MatchUpType string

const (
	// Each side consists of one player.
	MatchUpTypeSingles MatchUpType = "SINGLES"
	// Each side consists of two players.
	MatchUpTypeDoubles MatchUpType = "DOUBLES"
)

var AllMatchUpType = []MatchUpType{
	MatchUpTypeSingles,
	MatchUpTypeDoubles,
}

func (e MatchUpType) IsValid() bool {
	switch e {
	case MatchUpTypeSingles, MatchUpTypeDoubles:
		return true
	}
	return false
}

func (e MatchUpType) String() string {
	return string(e)
}

func (e *MatchUpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpType", str)
	}
	return nil
}

func (e MatchUpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Refers to the physical orientation of the tennis court itself, which could matter
// for sun, wind, or camera placement. For example, a stadium court may label one
// end 'North' and the other end 'South.' Auto assign A as north and B as south
// in the start. Switch the sides after every odd numbered game in a set or every
// 6 points in a tiebreak.
type PhysicalCourtSide string

const (
	// The north side of the court.
	PhysicalCourtSideNorthSide PhysicalCourtSide = "NORTH_SIDE"
	// The south side of the court.
	PhysicalCourtSideSouthSide PhysicalCourtSide = "SOUTH_SIDE"
)

var AllPhysicalCourtSide = []PhysicalCourtSide{
	PhysicalCourtSideNorthSide,
	PhysicalCourtSideSouthSide,
}

func (e PhysicalCourtSide) IsValid() bool {
	switch e {
	case PhysicalCourtSideNorthSide, PhysicalCourtSideSouthSide:
		return true
	}
	return false
}

func (e PhysicalCourtSide) String() string {
	return string(e)
}

func (e *PhysicalCourtSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PhysicalCourtSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PhysicalCourtSide", str)
	}
	return nil
}

func (e PhysicalCourtSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Denotes if a point has special significance in the context of the match.
type PointImportance string

const (
	// Regular point with no special significance.
	PointImportanceRegular PointImportance = "REGULAR"
	// Break point - opportunity to win opponent's service game.
	PointImportanceBreakPoint PointImportance = "BREAK_POINT"
	// Set point - opportunity to win the current set.
	PointImportanceSetPoint PointImportance = "SET_POINT"
	// Match point - opportunity to win the entire match.
	PointImportanceMatchPoint PointImportance = "MATCH_POINT"
	// Game point - opportunity to win the current game.
	PointImportanceGamePoint PointImportance = "GAME_POINT"
)

var AllPointImportance = []PointImportance{
	PointImportanceRegular,
	PointImportanceBreakPoint,
	PointImportanceSetPoint,
	PointImportanceMatchPoint,
	PointImportanceGamePoint,
}

func (e PointImportance) IsValid() bool {
	switch e {
	case PointImportanceRegular, PointImportanceBreakPoint, PointImportanceSetPoint, PointImportanceMatchPoint, PointImportanceGamePoint:
		return true
	}
	return false
}

func (e PointImportance) String() string {
	return string(e)
}

func (e *PointImportance) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PointImportance(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PointImportance", str)
	}
	return nil
}

func (e PointImportance) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Describes the main reason why a particular side won a tennis point.
type PointWinReason string

const (
	// The server hit a serve that the opponent could not touch or return.
	PointWinReasonAce PointWinReason = "ACE"
	// A shot that cleanly beats the opponent (not necessarily off the serve).
	PointWinReasonWinner PointWinReason = "WINNER"
	// The opponent was forced into an error by a strong or tricky shot.
	PointWinReasonForcedError PointWinReason = "FORCED_ERROR"
	// The opponent made an unforced error (e.g., an easy miss or unprovoked mistake).
	PointWinReasonUnforcedError PointWinReason = "UNFORCED_ERROR"
	// The server failed to execute a valid serve on both the first and second attempt.
	PointWinReasonDoubleFault PointWinReason = "DOUBLE_FAULT"
)

var AllPointWinReason = []PointWinReason{
	PointWinReasonAce,
	PointWinReasonWinner,
	PointWinReasonForcedError,
	PointWinReasonUnforcedError,
	PointWinReasonDoubleFault,
}

func (e PointWinReason) IsValid() bool {
	switch e {
	case PointWinReasonAce, PointWinReasonWinner, PointWinReasonForcedError, PointWinReasonUnforcedError, PointWinReasonDoubleFault:
		return true
	}
	return false
}

func (e PointWinReason) String() string {
	return string(e)
}

func (e *PointWinReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PointWinReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PointWinReason", str)
	}
	return nil
}

func (e PointWinReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a serve is a first or second attempt.
type ServeNumber string

const (
	// First serve attempt.
	ServeNumberFirstServe ServeNumber = "FIRST_SERVE"
	// Second serve attempt after a fault on the first serve.
	ServeNumberSecondServe ServeNumber = "SECOND_SERVE"
)

var AllServeNumber = []ServeNumber{
	ServeNumberFirstServe,
	ServeNumberSecondServe,
}

func (e ServeNumber) IsValid() bool {
	switch e {
	case ServeNumberFirstServe, ServeNumberSecondServe:
		return true
	}
	return false
}

func (e ServeNumber) String() string {
	return string(e)
}

func (e *ServeNumber) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServeNumber(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServeNumber", str)
	}
	return nil
}

func (e ServeNumber) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Specifies the style of serve (flat, kick, slice, or other).
type ServeStyle string

const (
	// A serve with minimal spin, often very fast and direct.
	ServeStyleFlat ServeStyle = "FLAT"
	// A serve with topspin that causes the ball to jump high upon bouncing.
	ServeStyleKick ServeStyle = "KICK"
	// A serve with sidespin, curving the ball in the air and off the court.
	ServeStyleSlice ServeStyle = "SLICE"
	// Any other specialized serve style (e.g., twist serve),
	// or unclassified serve approach.
	ServeStyleOther ServeStyle = "OTHER"
)

var AllServeStyle = []ServeStyle{
	ServeStyleFlat,
	ServeStyleKick,
	ServeStyleSlice,
	ServeStyleOther,
}

func (e ServeStyle) IsValid() bool {
	switch e {
	case ServeStyleFlat, ServeStyleKick, ServeStyleSlice, ServeStyleOther:
		return true
	}
	return false
}

func (e ServeStyle) String() string {
	return string(e)
}

func (e *ServeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServeStyle", str)
	}
	return nil
}

func (e ServeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents which service box a player is serving into or standing on
// during a tennis point. From the server's perspective:
// - The DEUCE_SIDE is on the right side.
// - The AD_SIDE is on the left side.
type ServiceBoxSide string

const (
	// The right side from the server's perspective, commonly called the 'deuce side'.
	ServiceBoxSideDeuceSide ServiceBoxSide = "DEUCE_SIDE"
	// The left side from the server's perspective, commonly called the 'ad side'.
	ServiceBoxSideAdSide ServiceBoxSide = "AD_SIDE"
)

var AllServiceBoxSide = []ServiceBoxSide{
	ServiceBoxSideDeuceSide,
	ServiceBoxSideAdSide,
}

func (e ServiceBoxSide) IsValid() bool {
	switch e {
	case ServiceBoxSideDeuceSide, ServiceBoxSideAdSide:
		return true
	}
	return false
}

func (e ServiceBoxSide) String() string {
	return string(e)
}

func (e *ServiceBoxSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceBoxSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceBoxSide", str)
	}
	return nil
}

func (e ServiceBoxSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the outcome of an individual shot in a tennis match.
// Different from PointWinReason as it focuses on the immediate result
// of the shot rather than the reason a point was won.
type ShotOutcome string

const (
	// Shot continued the rally (opponent returned it).
	ShotOutcomeContinuedRally ShotOutcome = "CONTINUED_RALLY"
	// Shot won the point for the hitter.
	ShotOutcomeWonPoint ShotOutcome = "WON_POINT"
	// Shot resulted in an error by the hitter.
	ShotOutcomeError ShotOutcome = "ERROR"
	// First serve fault (not a double fault yet).
	ShotOutcomeFirstFault ShotOutcome = "FIRST_FAULT"
)

var AllShotOutcome = []ShotOutcome{
	ShotOutcomeContinuedRally,
	ShotOutcomeWonPoint,
	ShotOutcomeError,
	ShotOutcomeFirstFault,
}

func (e ShotOutcome) IsValid() bool {
	switch e {
	case ShotOutcomeContinuedRally, ShotOutcomeWonPoint, ShotOutcomeError, ShotOutcomeFirstFault:
		return true
	}
	return false
}

func (e ShotOutcome) String() string {
	return string(e)
}

func (e *ShotOutcome) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShotOutcome(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShotOutcome", str)
	}
	return nil
}

func (e ShotOutcome) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Categorizes the type of shot in a rally.
type ShotType string

const (
	// The initial shot to start a point. Can be first or second serve.
	ShotTypeServe ShotType = "SERVE"
	// A shot hit after the serve, typically from the baseline (forehand or backhand).
	ShotTypeGroundStroke ShotType = "GROUND_STROKE"
	// A shot taken near the net, without the ball bouncing (e.g., a volley or half-volley).
	ShotTypeVolley ShotType = "VOLLEY"
)

var AllShotType = []ShotType{
	ShotTypeServe,
	ShotTypeGroundStroke,
	ShotTypeVolley,
}

func (e ShotType) IsValid() bool {
	switch e {
	case ShotTypeServe, ShotTypeGroundStroke, ShotTypeVolley:
		return true
	}
	return false
}

func (e ShotType) String() string {
	return string(e)
}

func (e *ShotType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShotType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShotType", str)
	}
	return nil
}

func (e ShotType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates which 'team side' a participant belongs to in a tennis match.
// For instance, in a doubles match, one side may be labeled Team A vs. Team B.
type TeamSide string

const (
	// The 'A' team side.
	TeamSideTeamA TeamSide = "TEAM_A"
	// The 'B' team side.
	TeamSideTeamB TeamSide = "TEAM_B"
)

var AllTeamSide = []TeamSide{
	TeamSideTeamA,
	TeamSideTeamB,
}

func (e TeamSide) IsValid() bool {
	switch e {
	case TeamSideTeamA, TeamSideTeamB:
		return true
	}
	return false
}

func (e TeamSide) String() string {
	return string(e)
}

func (e *TeamSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamSide", str)
	}
	return nil
}

func (e TeamSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
