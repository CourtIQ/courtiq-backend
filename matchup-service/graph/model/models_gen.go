// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/CourtIQ/courtiq-backend/matchup-service/graph/schema/scalars"
	"go.mongodb.org/mongo-driver/bson/primitive"
)

// Provides structured geographical details about a user's location.
// All fields are optional and can be omitted if unknown.
type Location struct {
	City      *string  `json:"city,omitempty" bson:"city,omitempty"`
	State     *string  `json:"state,omitempty" bson:"state,omitempty"`
	Country   *string  `json:"country,omitempty" bson:"country,omitempty"`
	Latitude  *float64 `json:"latitude,omitempty" bson:"latitude,omitempty"`
	Longitude *float64 `json:"longitude,omitempty" bson:"longitude,omitempty"`
}

type MatchUp struct {
	ID             primitive.ObjectID `json:"id" bson:"_id"`
	MatchUpFormat  *MatchUpFormat     `json:"matchUpFormat" bson:"matchUpFormat"`
	MatchUpTracker primitive.ObjectID `json:"matchUpTracker" bson:"matchUpTracker"`
	MatchUpType    MatchUpType        `json:"matchUpType" bson:"matchUpType"`
	MatchUpStatus  MatchUpStatus      `json:"matchUpStatus" bson:"matchUpStatus"`
	Participants   []*Participant     `json:"participants" bson:"participants"`
	StartTime      time.Time          `json:"startTime" bson:"startTime"`
	EndTime        *time.Time         `json:"endTime,omitempty" bson:"endTime,omitempty"`
	CreatedAt      time.Time          `json:"createdAt" bson:"createdAt"`
	LastUpdated    time.Time          `json:"lastUpdated" bson:"lastUpdated"`
}

// Overall "ruleset" of a tennis match:
// - Total sets (NumberOfSets)
// - Format details for each set
// - Optional alternate final set format
type MatchUpFormat struct {
	// How many sets will be played, restricted by the NumberOfSets scalar.
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// Default set format (e.g., games needed, deuce rules, etc.).
	SetFormat *SetFormat `json:"setFormat" bson:"setFormat"`
	// Alternate rules for the final set (e.g., 10-point tiebreak).
	// May be null if not used.
	FinalSetFormat *SetFormat `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

// Input representation of MatchUpFormat,
// mirroring the MatchUpFormat type.
type MatchUpFormatInput struct {
	// How many total sets are played, restricted by NumberOfSets (1, 3, 5).
	NumberOfSets scalars.NumberOfSets `json:"numberOfSets" bson:"numberOfSets"`
	// The default format for all sets except possibly the final one.
	SetFormat *SetFormatInput `json:"setFormat" bson:"setFormat"`
	// Alternate final set format, e.g., to allow a 10-point tiebreak.
	// Optional (null) if not used.
	FinalSetFormat *SetFormatInput `json:"finalSetFormat,omitempty" bson:"finalSetFormat,omitempty"`
}

type Mutation struct {
}

// Represents an individual participant in a tennis match (could be a singles player
// or one of the doubles players). Each participant is associated with one 'team side'
// (e.g., Team A or Team B).
type Participant struct {
	// A unique identifier for the participant.
	ID string `json:"id" bson:"_id"`
	// The name to be displayed (e.g., on scoreboards or UIs).
	DisplayName string `json:"displayName" bson:"displayName"`
	// The side (A or B) that this participant is associated with.
	TeamSide TeamSide `json:"teamSide" bson:"teamSide"`
}

type ParticipantInput struct {
	ID            *string  `json:"id" bson:"_id"`
	DisplayedName string   `json:"displayedName" bson:"displayedName"`
	TeamSide      TeamSide `json:"teamSide" bson:"teamSide"`
}

type Query struct {
}

// Describes a single set's structure:
// - Number of games (NumberOfGames)
// - Deuce rules
// - Tiebreak rules
type SetFormat struct {
	// Number of games to win a set, enforced by the NumberOfGames scalar.
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (Advantage, No-Ad, etc.).
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// If true, a player must lead by two games when at deuce.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// How the tiebreak is handled, if triggered.
	TiebreakFormat *TiebreakFormat `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
	// The game score at which a tiebreak starts (commonly 6).
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Input representation of SetFormat,
// mirroring the SetFormat type.
type SetFormatInput struct {
	// Number of games required to win a set (allowed values: 1, 3, 4, 5, 6, 10).
	NumberOfGames scalars.NumberOfGames `json:"numberOfGames" bson:"numberOfGames"`
	// Deuce rule type (e.g., ADV or NO_AD).
	// This remains required because you must specify some deuce rule.
	DeuceType DeuceType `json:"deuceType" bson:"deuceType"`
	// Whether a two-game lead is required to close the set.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
	// Optional tiebreak specification.
	// If omitted, it implies that no tiebreak is used.
	TiebreakFormat *TiebreakFormatInput `json:"tiebreakFormat,omitempty" bson:"tiebreakFormat,omitempty"`
	// Optional "trigger" at which a tiebreak starts (commonly 6).
	// If omitted or null, no tiebreak is triggered at any game score.
	TiebreakAt *int `json:"tiebreakAt,omitempty" bson:"tiebreakAt,omitempty"`
}

// Defines how a tiebreak is played:
// - Points needed (TiebreakPoints)
// - Whether a two-point lead is required
type TiebreakFormat struct {
	// How many points are needed to win the tiebreak
	// (allowed values: 5, 6, 7, 8, 9, 10).
	Points string `json:"points" bson:"points"`
	// If true, a two-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
}

// Input representation of TiebreakFormat,
// mirroring the TiebreakFormat type.
type TiebreakFormatInput struct {
	// Points needed to win the tiebreak (5, 6, 7, 8, 9, or 10).
	Points string `json:"points" bson:"points"`
	// If true, a 2-point lead is required to win the tiebreak.
	MustWinByTwo bool `json:"mustWinByTwo" bson:"mustWinByTwo"`
}

// Specifies the deuce rule, i.e., how a game proceeds once it reaches a 40-40 score.
type DeuceType string

const (
	// Sudden-death format: once the score reaches deuce (40-40),
	// the very next point decides the game — no requirement to win by two points.
	DeuceTypeSuddenDeath DeuceType = "SUDDEN_DEATH"
	// Traditional deuce format: a player must secure a two-point lead to win
	// (i.e., 'advantage' followed by another point).
	DeuceTypeNormalDeuce DeuceType = "NORMAL_DEUCE"
	// One-deuce format: once the score reaches deuce, only one deuce is allowed.
	// After that, the next point wins the game, regardless of any lead requirement.
	DeuceTypeOneDeuce DeuceType = "ONE_DEUCE"
)

var AllDeuceType = []DeuceType{
	DeuceTypeSuddenDeath,
	DeuceTypeNormalDeuce,
	DeuceTypeOneDeuce,
}

func (e DeuceType) IsValid() bool {
	switch e {
	case DeuceTypeSuddenDeath, DeuceTypeNormalDeuce, DeuceTypeOneDeuce:
		return true
	}
	return false
}

func (e DeuceType) String() string {
	return string(e)
}

func (e *DeuceType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DeuceType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DeuceType", str)
	}
	return nil
}

func (e DeuceType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GameScore string

const (
	GameScoreLove      GameScore = "LOVE"
	GameScoreFifteen   GameScore = "FIFTEEN"
	GameScoreThirty    GameScore = "THIRTY"
	GameScoreForty     GameScore = "FORTY"
	GameScoreAdvantage GameScore = "ADVANTAGE"
)

var AllGameScore = []GameScore{
	GameScoreLove,
	GameScoreFifteen,
	GameScoreThirty,
	GameScoreForty,
	GameScoreAdvantage,
}

func (e GameScore) IsValid() bool {
	switch e {
	case GameScoreLove, GameScoreFifteen, GameScoreThirty, GameScoreForty, GameScoreAdvantage:
		return true
	}
	return false
}

func (e GameScore) String() string {
	return string(e)
}

func (e *GameScore) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GameScore(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GameScore", str)
	}
	return nil
}

func (e GameScore) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroundStrokeStyle string

const (
	GroundStrokeStyleSlice       GroundStrokeStyle = "SLICE"
	GroundStrokeStyleTopspin     GroundStrokeStyle = "TOPSPIN"
	GroundStrokeStyleFlat        GroundStrokeStyle = "FLAT"
	GroundStrokeStyleLob         GroundStrokeStyle = "LOB"
	GroundStrokeStyleDropShot    GroundStrokeStyle = "DROP_SHOT"
	GroundStrokeStyleCrosscourt  GroundStrokeStyle = "CROSSCOURT"
	GroundStrokeStyleDownTheLine GroundStrokeStyle = "DOWN_THE_LINE"
	GroundStrokeStyleSmash       GroundStrokeStyle = "SMASH"
)

var AllGroundStrokeStyle = []GroundStrokeStyle{
	GroundStrokeStyleSlice,
	GroundStrokeStyleTopspin,
	GroundStrokeStyleFlat,
	GroundStrokeStyleLob,
	GroundStrokeStyleDropShot,
	GroundStrokeStyleCrosscourt,
	GroundStrokeStyleDownTheLine,
	GroundStrokeStyleSmash,
}

func (e GroundStrokeStyle) IsValid() bool {
	switch e {
	case GroundStrokeStyleSlice, GroundStrokeStyleTopspin, GroundStrokeStyleFlat, GroundStrokeStyleLob, GroundStrokeStyleDropShot, GroundStrokeStyleCrosscourt, GroundStrokeStyleDownTheLine, GroundStrokeStyleSmash:
		return true
	}
	return false
}

func (e GroundStrokeStyle) String() string {
	return string(e)
}

func (e *GroundStrokeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeStyle", str)
	}
	return nil
}

func (e GroundStrokeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type GroundStrokeType string

const (
	GroundStrokeTypeForehand GroundStrokeType = "FOREHAND"
	GroundStrokeTypeBackhand GroundStrokeType = "BACKHAND"
)

var AllGroundStrokeType = []GroundStrokeType{
	GroundStrokeTypeForehand,
	GroundStrokeTypeBackhand,
}

func (e GroundStrokeType) IsValid() bool {
	switch e {
	case GroundStrokeTypeForehand, GroundStrokeTypeBackhand:
		return true
	}
	return false
}

func (e GroundStrokeType) String() string {
	return string(e)
}

func (e *GroundStrokeType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = GroundStrokeType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid GroundStrokeType", str)
	}
	return nil
}

func (e GroundStrokeType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the different stages or outcomes a tennis match can go through.
type MatchUpStatus string

const (
	// The match is scheduled in advance but has not yet started.
	MatchUpStatusScheduled MatchUpStatus = "SCHEDULED"
	// The match is currently in progress.
	MatchUpStatusInProgress MatchUpStatus = "IN_PROGRESS"
	// The match has ended with a clear result (winner determined).
	MatchUpStatusCompleted MatchUpStatus = "COMPLETED"
	// The match has been paused (e.g., due to weather or other external conditions)
	// and is expected to resume later.
	MatchUpStatusSuspended MatchUpStatus = "SUSPENDED"
	// The match has been canceled and will not be played or resumed.
	MatchUpStatusCancelled MatchUpStatus = "CANCELLED"
	// The match was started but ultimately abandoned partway and will not be completed.
	MatchUpStatusAbandoned MatchUpStatus = "ABANDONED"
	// One player (or team) has 'retired' from the match — usually due to injury.
	// The other player (or team) is declared the winner by default.
	MatchUpStatusRetired MatchUpStatus = "RETIRED"
	// The match creation or scheduling is in progress, or it is awaiting final
	// confirmation (e.g., from players or for court availability).
	MatchUpStatusRequested MatchUpStatus = "REQUESTED"
)

var AllMatchUpStatus = []MatchUpStatus{
	MatchUpStatusScheduled,
	MatchUpStatusInProgress,
	MatchUpStatusCompleted,
	MatchUpStatusSuspended,
	MatchUpStatusCancelled,
	MatchUpStatusAbandoned,
	MatchUpStatusRetired,
	MatchUpStatusRequested,
}

func (e MatchUpStatus) IsValid() bool {
	switch e {
	case MatchUpStatusScheduled, MatchUpStatusInProgress, MatchUpStatusCompleted, MatchUpStatusSuspended, MatchUpStatusCancelled, MatchUpStatusAbandoned, MatchUpStatusRetired, MatchUpStatusRequested:
		return true
	}
	return false
}

func (e MatchUpStatus) String() string {
	return string(e)
}

func (e *MatchUpStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpStatus", str)
	}
	return nil
}

func (e MatchUpStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates whether a match is singles (1 vs. 1) or doubles (2 vs. 2).
type MatchUpType string

const (
	// Each side consists of one player.
	MatchUpTypeSingles MatchUpType = "SINGLES"
	// Each side consists of two players.
	MatchUpTypeDoubles MatchUpType = "DOUBLES"
)

var AllMatchUpType = []MatchUpType{
	MatchUpTypeSingles,
	MatchUpTypeDoubles,
}

func (e MatchUpType) IsValid() bool {
	switch e {
	case MatchUpTypeSingles, MatchUpTypeDoubles:
		return true
	}
	return false
}

func (e MatchUpType) String() string {
	return string(e)
}

func (e *MatchUpType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = MatchUpType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid MatchUpType", str)
	}
	return nil
}

func (e MatchUpType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Refers to the physical orientation of the tennis court itself, which could matter
// for sun, wind, or camera placement. For example, a stadium court may label one
// end 'North' and the other end 'South.'
type PhysicalCourtSide string

const (
	// The north side of the court.
	PhysicalCourtSideNorthSide PhysicalCourtSide = "NORTH_SIDE"
	// The south side of the court.
	PhysicalCourtSideSouthSide PhysicalCourtSide = "SOUTH_SIDE"
)

var AllPhysicalCourtSide = []PhysicalCourtSide{
	PhysicalCourtSideNorthSide,
	PhysicalCourtSideSouthSide,
}

func (e PhysicalCourtSide) IsValid() bool {
	switch e {
	case PhysicalCourtSideNorthSide, PhysicalCourtSideSouthSide:
		return true
	}
	return false
}

func (e PhysicalCourtSide) String() string {
	return string(e)
}

func (e *PhysicalCourtSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PhysicalCourtSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PhysicalCourtSide", str)
	}
	return nil
}

func (e PhysicalCourtSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PlayingSide string

const (
	PlayingSideDeuce PlayingSide = "DEUCE"
	PlayingSideAd    PlayingSide = "AD"
)

var AllPlayingSide = []PlayingSide{
	PlayingSideDeuce,
	PlayingSideAd,
}

func (e PlayingSide) IsValid() bool {
	switch e {
	case PlayingSideDeuce, PlayingSideAd:
		return true
	}
	return false
}

func (e PlayingSide) String() string {
	return string(e)
}

func (e *PlayingSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PlayingSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PlayingSide", str)
	}
	return nil
}

func (e PlayingSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type PointWinReason string

const (
	PointWinReasonAce           PointWinReason = "ACE"
	PointWinReasonWinner        PointWinReason = "WINNER"
	PointWinReasonForcedError   PointWinReason = "FORCED_ERROR"
	PointWinReasonUnforcedError PointWinReason = "UNFORCED_ERROR"
	PointWinReasonDoubleFault   PointWinReason = "DOUBLE_FAULT"
)

var AllPointWinReason = []PointWinReason{
	PointWinReasonAce,
	PointWinReasonWinner,
	PointWinReasonForcedError,
	PointWinReasonUnforcedError,
	PointWinReasonDoubleFault,
}

func (e PointWinReason) IsValid() bool {
	switch e {
	case PointWinReasonAce, PointWinReasonWinner, PointWinReasonForcedError, PointWinReasonUnforcedError, PointWinReasonDoubleFault:
		return true
	}
	return false
}

func (e PointWinReason) String() string {
	return string(e)
}

func (e *PointWinReason) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = PointWinReason(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid PointWinReason", str)
	}
	return nil
}

func (e PointWinReason) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ServeStyle string

const (
	ServeStyleFlat  ServeStyle = "FLAT"
	ServeStyleKick  ServeStyle = "KICK"
	ServeStyleSlice ServeStyle = "SLICE"
	ServeStyleOther ServeStyle = "OTHER"
)

var AllServeStyle = []ServeStyle{
	ServeStyleFlat,
	ServeStyleKick,
	ServeStyleSlice,
	ServeStyleOther,
}

func (e ServeStyle) IsValid() bool {
	switch e {
	case ServeStyleFlat, ServeStyleKick, ServeStyleSlice, ServeStyleOther:
		return true
	}
	return false
}

func (e ServeStyle) String() string {
	return string(e)
}

func (e *ServeStyle) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServeStyle(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServeStyle", str)
	}
	return nil
}

func (e ServeStyle) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents which service box a player is serving into or standing on
// during a tennis point. From the server's perspective:
// - The DEUCE_SIDE is on the right side.
// - The AD_SIDE is on the left side.
type ServiceBoxSide string

const (
	// The right side from the server's perspective, commonly called the 'deuce side'.
	ServiceBoxSideDeuceSide ServiceBoxSide = "DEUCE_SIDE"
	// The left side from the server's perspective, commonly called the 'ad side'.
	ServiceBoxSideAdSide ServiceBoxSide = "AD_SIDE"
)

var AllServiceBoxSide = []ServiceBoxSide{
	ServiceBoxSideDeuceSide,
	ServiceBoxSideAdSide,
}

func (e ServiceBoxSide) IsValid() bool {
	switch e {
	case ServiceBoxSideDeuceSide, ServiceBoxSideAdSide:
		return true
	}
	return false
}

func (e ServiceBoxSide) String() string {
	return string(e)
}

func (e *ServiceBoxSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ServiceBoxSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ServiceBoxSide", str)
	}
	return nil
}

func (e ServiceBoxSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ShotType string

const (
	ShotTypeServe        ShotType = "SERVE"
	ShotTypeGroundStroke ShotType = "GROUND_STROKE"
	ShotTypeVolley       ShotType = "VOLLEY"
)

var AllShotType = []ShotType{
	ShotTypeServe,
	ShotTypeGroundStroke,
	ShotTypeVolley,
}

func (e ShotType) IsValid() bool {
	switch e {
	case ShotTypeServe, ShotTypeGroundStroke, ShotTypeVolley:
		return true
	}
	return false
}

func (e ShotType) String() string {
	return string(e)
}

func (e *ShotType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ShotType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ShotType", str)
	}
	return nil
}

func (e ShotType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Indicates which 'team side' a participant belongs to in a tennis match.
// For instance, in a doubles match, one side may be labeled Team A vs. Team B.
type TeamSide string

const (
	// The 'A' team side.
	TeamSideTeamA TeamSide = "TEAM_A"
	// The 'B' team side.
	TeamSideTeamB TeamSide = "TEAM_B"
)

var AllTeamSide = []TeamSide{
	TeamSideTeamA,
	TeamSideTeamB,
}

func (e TeamSide) IsValid() bool {
	switch e {
	case TeamSideTeamA, TeamSideTeamB:
		return true
	}
	return false
}

func (e TeamSide) String() string {
	return string(e)
}

func (e *TeamSide) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TeamSide(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TeamSide", str)
	}
	return nil
}

func (e TeamSide) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPublic  Visibility = "PUBLIC"
	VisibilityPrivate Visibility = "PRIVATE"
	VisibilityFriends Visibility = "FRIENDS"
	VisibilityCoaches Visibility = "COACHES"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityPrivate,
	VisibilityFriends,
	VisibilityCoaches,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityPrivate, VisibilityFriends, VisibilityCoaches:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
