// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package model

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"go.mongodb.org/mongo-driver/bson/primitive"
)

type Relationship interface {
	IsEntity()
	IsRelationship()
	GetID() primitive.ObjectID
	GetParticipants() []primitive.ObjectID
	GetType() RelationshipType
	GetStatus() RelationshipStatus
	GetCreatedAt() time.Time
	GetUpdatedAt() time.Time
}

type Coachship struct {
	ID           primitive.ObjectID   `json:"id" bson:"_id"`
	Participants []primitive.ObjectID `json:"participants" bson:"participants"`
	Type         RelationshipType     `json:"type" bson:"type"`
	Status       RelationshipStatus   `json:"status" bson:"status"`
	CreatedAt    time.Time            `json:"createdAt" bson:"createdAt"`
	UpdatedAt    time.Time            `json:"updatedAt" bson:"updatedAt"`
	CoachID      primitive.ObjectID   `json:"coachId" bson:"coachId"`
	StudentID    primitive.ObjectID   `json:"studentId" bson:"studentId"`
}

func (Coachship) IsRelationship()                {}
func (this Coachship) GetID() primitive.ObjectID { return this.ID }
func (this Coachship) GetParticipants() []primitive.ObjectID {
	if this.Participants == nil {
		return nil
	}
	interfaceSlice := make([]primitive.ObjectID, 0, len(this.Participants))
	for _, concrete := range this.Participants {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Coachship) GetType() RelationshipType     { return this.Type }
func (this Coachship) GetStatus() RelationshipStatus { return this.Status }
func (this Coachship) GetCreatedAt() time.Time       { return this.CreatedAt }
func (this Coachship) GetUpdatedAt() time.Time       { return this.UpdatedAt }

func (Coachship) IsEntity() {}

type Friendship struct {
	ID           primitive.ObjectID   `json:"id" bson:"_id"`
	Participants []primitive.ObjectID `json:"participants" bson:"participants"`
	Type         RelationshipType     `json:"type" bson:"type"`
	Status       RelationshipStatus   `json:"status" bson:"status"`
	CreatedAt    time.Time            `json:"createdAt" bson:"createdAt"`
	UpdatedAt    time.Time            `json:"updatedAt" bson:"updatedAt"`
	SenderID     primitive.ObjectID   `json:"senderId" bson:"senderId"`
	ReceiverID   primitive.ObjectID   `json:"receiverId" bson:"receiverId"`
}

func (Friendship) IsRelationship()                {}
func (this Friendship) GetID() primitive.ObjectID { return this.ID }
func (this Friendship) GetParticipants() []primitive.ObjectID {
	if this.Participants == nil {
		return nil
	}
	interfaceSlice := make([]primitive.ObjectID, 0, len(this.Participants))
	for _, concrete := range this.Participants {
		interfaceSlice = append(interfaceSlice, concrete)
	}
	return interfaceSlice
}
func (this Friendship) GetType() RelationshipType     { return this.Type }
func (this Friendship) GetStatus() RelationshipStatus { return this.Status }
func (this Friendship) GetCreatedAt() time.Time       { return this.CreatedAt }
func (this Friendship) GetUpdatedAt() time.Time       { return this.UpdatedAt }

func (Friendship) IsEntity() {}

type Mutation struct {
}

type Query struct {
}

// Represents the possible status of a relationship between users.
type RelationshipStatus string

const (
	// The relationship is in a pending state, meaning a request has been sent but not yet accepted.
	RelationshipStatusPending RelationshipStatus = "PENDING"
	// The relationship is active, meaning the request has been accepted and the relationship is established.
	RelationshipStatusActive RelationshipStatus = "ACTIVE"
)

var AllRelationshipStatus = []RelationshipStatus{
	RelationshipStatusPending,
	RelationshipStatusActive,
}

func (e RelationshipStatus) IsValid() bool {
	switch e {
	case RelationshipStatusPending, RelationshipStatusActive:
		return true
	}
	return false
}

func (e RelationshipStatus) String() string {
	return string(e)
}

func (e *RelationshipStatus) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelationshipStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RelationshipStatus", str)
	}
	return nil
}

func (e RelationshipStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

// Represents the different types of relationships that can exist between users.
type RelationshipType string

const (
	// A friendship relationship between two users.
	RelationshipTypeFriendship RelationshipType = "FRIENDSHIP"
	// A coaching relationship between a coach and a coachee.
	RelationshipTypeCoachship RelationshipType = "COACHSHIP"
)

var AllRelationshipType = []RelationshipType{
	RelationshipTypeFriendship,
	RelationshipTypeCoachship,
}

func (e RelationshipType) IsValid() bool {
	switch e {
	case RelationshipTypeFriendship, RelationshipTypeCoachship:
		return true
	}
	return false
}

func (e RelationshipType) String() string {
	return string(e)
}

func (e *RelationshipType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RelationshipType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RelationshipType", str)
	}
	return nil
}

func (e RelationshipType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type Visibility string

const (
	VisibilityPublic  Visibility = "PUBLIC"
	VisibilityPrivate Visibility = "PRIVATE"
	VisibilityFriends Visibility = "FRIENDS"
	VisibilityCoaches Visibility = "COACHES"
)

var AllVisibility = []Visibility{
	VisibilityPublic,
	VisibilityPrivate,
	VisibilityFriends,
	VisibilityCoaches,
}

func (e Visibility) IsValid() bool {
	switch e {
	case VisibilityPublic, VisibilityPrivate, VisibilityFriends, VisibilityCoaches:
		return true
	}
	return false
}

func (e Visibility) String() string {
	return string(e)
}

func (e *Visibility) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = Visibility(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid Visibility", str)
	}
	return nil
}

func (e Visibility) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
